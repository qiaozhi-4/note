------

### 说说对“锁”的了解

- **考查意图**：考察对并发安全基本概念的认知。

- 口语化答案：

  “在多线程环境下，‘锁’其实就是一种资源保护机制。当多个线程同时去操作同一个变量（比如抢票、改余额）时，为了防止数据乱套，我们需要给这段逻辑加一把‘锁’，确保同一时刻只有一个线程能操作它。

  在 Java 中，锁可以从不同维度分类：

  1. 从**悲观程度**看，分为悲观锁（我觉得肯定有人抢，先锁住再说）和乐观锁（我觉得没人抢，更新时再检查）。
  2. 从**公平性**看，分为公平锁（排队）和非公平锁（允许插队）。
  3. 从**性能优化**看，JVM 对内置锁做了很多优化，比如偏向锁、轻量级锁和重量级锁，目的是为了减少在高并发下的性能开销。”

- **亮点建议**：提到“分类维度”会让你的逻辑显得非常专业，而不是东一榔头西一棒子。

------

### synchronized 和 Lock 的区别

- **考查意图**：考察 Java 并发工具的深度掌握。

- 口语化答案：

  “这两者最本质的区别是：一个是关键字，一个是类。

  `synchronized` 是 Java 自带的关键字，属于**内置锁**。它用起来最简单，不需要手动释放，JVM 会帮我们处理，而且它是不可中断的。

  `Lock`（比如 `ReentrantLock`）是一个接口，属于**显式锁**。它比 `synchronized` 灵活得多：

  1. 它支持**尝试获取锁**（`tryLock`），拿不到就算了，不用死等。
  2. 它支持**中断响应**，能避免死锁。
  3. 它能实现**公平锁**。
  4. 它能配合 `Condition` 实现**精准唤醒**某个线程，而不是像 `notifyAll` 那样喊醒所有人。”

- **亮点建议**：重点突出 Lock 的“灵活性”和“主动控制权”。

------

### 什么是乐观锁

- **考查意图**：考察对无锁编程和 CAS 机制的理解。

- 口语化答案：

  “乐观锁其实不是真的‘加锁’，它更像是一种冲突检测机制。

  它的核心思想是：操作数据的时候不锁表、不锁行，但在最后更新的那一刻，会去比对一下：‘我刚才拿到的版本号（或者值）跟我现在准备更新时看到的是不是同一个？’。

  在 Java 里，它的实现基础是 **CAS (Compare And Swap)**。比如 `AtomicInteger` 里的 `incrementAndGet()`。它的好处是**效率高**，因为没有线程挂起和切换的开销，非常适合‘读多写少’的场景。但如果竞争太激烈，会导致 CPU 一直在自旋重试，反而费电、费性能。”

- **亮点建议**：一定要提到 CAS 和原子类（AtomicInteger），并指出它的缺点（自旋开销）。

------

### 说说线程池

- **考查意图**：考察对多线程管理和资源优化的理解。

- 口语化答案：

  “线程池就是为了复用线程，避免频繁创建和销毁线程带来的性能损耗。

  面试中比较核心的是它的 **7 个参数**，我通常这么理解：核心线程数（常驻老员工）、最大线程数（加上临时工的总数）、保持存活时间（临时工没活了多久走人）、任务队列（排队的等候区）和拒绝策略（人满了怎么办）。

  **它的工作流程是：** 任务来了先给老员工做，老员工满了进等候区，等候区也满了再请临时工，最后要是全满了，就执行拒绝策略。

  我们在安卓开发中要注意，不要用 `Executors` 快捷创建，因为它默认的任务队列太长（Integer.MAX_VALUE），容易导致 OOM，最好根据 CPU 核数自定义 `ThreadPoolExecutor`。”

- **亮点建议**：用“老员工/临时工”做比喻能让面试官觉得你理解透彻了。

------

### 安卓子线程回调

- **考查意图**：考察线程间通信（Android 异步机制）。

- 口语化答案：

  “在安卓里，子线程是不能直接操作 UI 的，所以子线程做完耗时任务（比如网络请求）后，必须把结果传回主线程。

  常见的实现方式有：

  1. **Handler 机制**：这是最底层的，子线程发个 `Message` 或者 `post(Runnable)`，在主线程处理。
  2. **接口回调 + Activity.runOnUiThread**：在子线程里执行完逻辑，通过 Interface 回调，并在实现处切换到主线程。
  3. **LiveData/ViewModel**：现在常用的 MVVM 模式，子线程 `postValue`，UI 层观察到变化后自动更新。
  4. **协程 (Coroutines)**：这是目前最推荐的。用 `withContext(Dispatchers.Main)` 就能直接切回主线程，代码写起来像同步一样，非常优雅。”

- **亮点建议**：一定要提到协程（Coroutines），这体现了你对新技术的跟进。

------

### 数组和链表的区别

- **考查意图**：考察基础数据结构和内存模型。

- 口语化答案：

  “这两者最核心的区别在于内存布局和访问效率。

  **数组**在内存里是**连续的一块**。它的优点是**查询极快**（可以通过下标直接定位 O(1)），但缺点是**增删慢**，因为插入或删除一个元素，后面的都要整体挪位，而且长度是固定的。

  **链表**是由一个个‘节点’组成的，它们在内存里是**分散存储**的，靠指针连着。它的优点是**增删快**（只要改个指针指向就行 O(1)），但**查询慢**，必须从头开始一个一个往后数。

  在开发中，如果我们确定数据量且频繁查询，选 ArrayList（底层是数组）；如果需要频繁在中间插入删除，选 LinkedList（底层是链表）。”

- **亮点建议**：提到“内存连续性”和具体的时间复杂度（O(1) vs O(n)）。

------

### 安卓开发模式（架构模式）

在 Android 面试中，**架构模式**是区分“初级开发者”与“中级/高级开发者”的分水岭。面试官不仅看你是否会用这些模式，更看重你是否理解它们**为什么要演进**。

Android 架构经历了从 **MVC** 到 **MVP**，再到如今官方推荐的 **MVVM** 和探索中的 **MVI**。

------

#### 🏛️ 1. MVC (Model-View-Controller)

这是最原始的模式。

- **Model:** 数据层（网络、数据库）。
- **View:** XML 布局。
- **Controller:** Activity 或 Fragment。
- **缺点：** 在 Android 中，Activity 既要处理 UI 逻辑，又要处理业务逻辑。导致 Activity 动辄几千行代码，变成“万能类”，极难维护和测试。

------

#### 🏗️ 2. MVP (Model-View-Presenter)

为了解决 MVC 中 Activity 负担过重的问题，MVP 曾风靡一时。

- **Model:** 数据层。
- **View:** Activity / Fragment。
- **Presenter:** 中间人，处理业务逻辑，通过 **接口（Interface）** 操控 View。
- **优点：** 逻辑解耦，Activity 只负责显示。
- **缺点：** 接口太多！每写一个页面都要写一套接口，且 Presenter 依然持有 View 的引用，容易导致内存泄漏。

------

#### 🚀 3. MVVM (Model-View-ViewModel) —— **目前的主流/官方推荐**

随着 Jetpack 组件的推出，MVVM 成为 Android 开发的标准架构。

- **Model:** 数据源。
- **View:** Activity / Fragment / Compose，通过“观察者模式”自动更新。
- **ViewModel:** 存储和管理与 UI 相关的数据，**不持有 View 的引用**。
- **核心特性：数据驱动。** ViewModel 里的数据变了，View 自动刷。

------

#### 🧬 4. MVI (Model-View-Intent) —— **进阶探索**

这是受 React 启发，在 Compose 开发中越来越流行的模式。

- **核心思想：单向数据流 (Unidirectional Data Flow)。**
- **Intent:** 用户的操作（如点击按钮）。
- **State:** 唯一的数据源。界面永远只是状态的反映。
- **优点：** 状态极度可控，非常适合复杂的 Compose 界面。

------

#### 🏁 性能优化面试实战：架构如何影响性能？

面试官会问：**“为什么要从 MVP 转向 MVVM？这对性能优化有什么好处？”**

##### 💬 口语化参考答案

“我觉得架构模式不仅仅是代码怎么写的问题，它直接关系到 App 的**稳定性和性能**。

1. **减少内存泄漏：** 以前在 MVP 里，Presenter 持有 Activity 的强引用，如果异步请求没回来 Activity 就销毁了，就很容易泄漏。而 **ViewModel 不持有 View 引用**，它通过 `LiveData` 或 `Flow` 发送通知，View 销毁后会自动取消观察，这从根源上减少了内存泄漏。
2. **生命周期感知：** Jetpack 的架构组件能感知生命周期。这意味着数据只会在 View 处于活跃状态时（如 `onStart`）才推送，避免了在后台刷新 UI 造成的无谓功耗和潜在崩溃。
3. **减少重复初始化：** `ViewModel` 在配置变更（比如横竖屏切换）时不会被销毁。这意味着我们不需要重新请求网络、重新解析数据，大大提升了用户体验和资源利用率。”



### 安卓app的生命周期

- **考查意图**：考察对 Android 系统组件核心机制的理解。

- 口语化答案：

  “通常我们指的是 Activity 的生命周期，主要有 7 个阶段：

  - **onCreate**: 第一次创建，做初始化。
  - **onStart/onResume**: 准备展示。`onResume` 时用户才能真正开始交互。
  - **onPause/onStop**: 失去焦点或不可见。如果想保存点数据或停止动画，这里是关键点。
  - **onDestroy**: 销毁。
  - **onRestart**: 从后台重新回到前台。

  **容易被问到的细节是：** A 页面跳到 B 页面，生命周期顺序是什么？其实是 A 先执行 `onPause`，等 B 完成 `onCreate/onStart/onResume` 后，A 再执行 `onStop`。这样设计是为了让新页面尽快展示，保证流畅感。”

- **亮点建议**：提到 A 跳 B 的具体顺序是一个非常加分的细节。

------

### 常用布局

#### 🏛️ 第一部分：传统 View 系统布局 (XML)

这是目前大多数存量项目（包括你可能面试的项目）的主力。

##### 1. ConstraintLayout (约束布局) —— **性能王者**

这是面试最爱考的。它旨在解决**布局嵌套过深**的问题。

- **核心逻辑：** 通过建立组件之间的相对关系（比如：A 在 B 的右边）来定位。
- **应用场景：** **复杂界面**的首选。它能把原本需要三四层嵌套的布局拍平成一层。
- **性能考点：** 减少了 View 树的深度，从而显著降低了 `onMeasure`（测量）阶段的耗时。

##### 2. LinearLayout (线性布局)

- **核心逻辑：** 简单地按水平或垂直方向排列。
- **应用场景：** 非常简单的排版，或者利用 `layout_weight`（权重）平分空间。
- **性能注意：** 尽量避免在内部再嵌套多个 `layout_weight`，这会导致二次测量。

##### 3. FrameLayout (帧布局)

- **核心逻辑：** 像叠纸片一样，后添加的盖在前一个上面。
- **应用场景：** **Fragment 的容器**，或者单纯想重叠两个 View（比如在图片上盖一个 Loading 图标）。它是所有布局里性能最轻量的。

##### 4. RelativeLayout (相对布局)

- **核心逻辑：** 类似于早期简化版的约束布局。
- **现状：** 基本已被 `ConstraintLayout` 取代，因为它在处理复杂依赖时性能不如后者。

------

#### ⚡ 第二部分：现代 Compose 布局 (声明式)

如果你在 M3 (Material 3) 中使用 `@Composable`，你会发现布局变得极其直观。

| **Compose 组件**     | **对应 XML 布局**         | **描述**                                       |
| -------------------- | ------------------------- | ---------------------------------------------- |
| **Box**              | FrameLayout               | 堆叠布局                                       |
| **Column**           | LinearLayout (Vertical)   | 垂直排列                                       |
| **Row**              | LinearLayout (Horizontal) | 水平排列                                       |
| **ConstraintLayout** | ConstraintLayout          | 同样支持复杂约束逻辑                           |
| **LazyColumn / Row** | **RecyclerView**          | **核心考点**：用于长列表的丝滑滚动（性能极佳） |

------

#### 🏁 性能优化面试实战：关于布局优化

面试官必问：**“如果一个页面滑动卡顿，你如何进行布局优化？”**

##### 💬 口语化参考答案

“我会从以下四个维度来做：

1. 减少层级（拍平布局）：

   这是最有效的手段。我会优先使用 ConstraintLayout。如果一个布局嵌套超过 3 层，解析 XML 和反复测量的开销就会变大。

2. 避免过度绘制（Overdraw）：

   我会通过开发者选项里的‘显示过度绘制’区域。如果红色区域太多，说明很多背景被重叠画了好几次。我会移除布局中不必要的 android:background（比如 Activity 已经有背景了，子布局就没必要再设一遍）。

3. 按需加载（ViewStub）：

   对于一些不常用的界面（比如‘网络错误提示’或‘红包弹窗’），我不会直接写在 XML 里，而是使用 ViewStub。它在初始化时是不占内存的，只有真正需要显示时才会 inflate。

4. 复用组件（Include 与 Merge）：

   我会用 <include> 复用代码，同时配合 <merge> 标签。<merge> 可以减少一层冗余的父容器（比如合并掉多余的 FrameLayout），直接减少 View 树深度。”

------

#### 💡 进阶指导：亮点建议

- **提到 `RecyclerView`：** 虽然它不是严格意义上的“布局管理器”，但它是 Android 性能优化的灵魂。提到它的“四级缓存”和“ViewHolder 复用”会显得你很有深度。
- **Compose 的性能：** 提到 Compose 避免了繁琐的 XML 解析，通过 `Recomposition`（重组）实现更精细的刷新。

------

### 列表加载实现

- **考查意图**：考察对长列表性能优化、View 复用机制以及新旧 UI 框架（命令式 vs 声明式）的掌握。
- **口语化答案**： “目前 Android 实现列表加载主要有两种主流方式，取决于项目使用的是传统的 XML 还是现代的 Compose：
  1. **RecyclerView (传统 XML 方式)**： 这是最经典的做法，核心是 **View 复用机制**。
     - **Adapter**：负责把数据和 Item 绑定。
     - **ViewHolder**：这是性能的关键，它缓存了 View 的引用，避免了频繁调用 `findViewById`。
     - **LayoutManager**：决定是垂直列表、网格还是瀑布流。
     - **优化**：我们会配合 `DiffUtil` 进行局部刷新，而不是全量刷新，这样性能更高。
  2. **LazyColumn (现代 Compose 方式)**： 这是声明式 UI 下的实现，代码量比 RecyclerView 少得多。
     - **按需加载**：它只渲染当前屏幕可见的 Item，滑动时动态销毁和创建，逻辑上对应 RecyclerView。
     - **DSL 语法**：直接在 `items(dataList) { ... }` 里写 UI 逻辑，不需要写繁琐的 Adapter 和 ViewHolder。
     - **性能**：Compose 内部会自动处理复用逻辑，开发者只需要关注状态（State）的变化。
  3. **共同的进阶处理**：
     - **分页加载**：如果是大数据量，我会配合 **Paging 3 库**。它能很好地处理‘加载中’、‘错误重试’以及‘预取数据’的逻辑，而且同时支持 RecyclerView 和 LazyColumn。
     - **下拉刷新**：XML 常用 `SwipeRefreshLayout`，Compose 则常用 `pullRefresh` 修饰符。”

------

### 你了解安卓协程吗

- **考查意图**：考察对 Kotlin 高级特性的掌握和异步编程思维。

- 口语化答案：

  “了解。协程简单来说就是一种轻量级的线程切换框架。

  它最大的痛点解决者在于：**用同步的代码风格写异步逻辑**。以前我们做网络请求，要么是回调嵌套（Callback Hell），要么是 RxJava 的一长串链式调用，代码很难读。

  用了协程，我只要在一个 `suspend` 函数里写逻辑，通过 `withContext(Dispatchers.IO)` 去切线程切到后台执行耗时任务，执行完它会自动回到主线程继续跑下一行代码。**不阻塞、不嵌套**，逻辑非常清晰。它还跟生命周期（LifecycleScope）绑定得很好，Activity 销毁时会自动取消任务，防止内存泄漏。”

- **亮点建议**：强调“同步风格写异步”和“生命周期自动管理”。

------

### 说说 ViewModel 的使用

- **考查意图**：考察架构设计（MVVM）和数据持久性。

- 口语化答案：

  “ViewModel 是 Jetpack 组件库里的核心。它的主要作用有两个：

  第一，**解耦 UI 和数据**。Activity 只负责展示数据和监听用户点击，具体的业务逻辑和数据获取都丢给 ViewModel 去做。

  第二，**生命周期感应**。这是它最牛的地方，它的生命周期比 Activity 长。比如手机屏幕旋转，Activity 会销毁重建，如果是普通的变量数据就丢了，但 ViewModel 会一直存活，等到新 Activity 起来后，它还是原来的那个实例，数据无缝衔接。

  通常我们会配合 **LiveData** 或者 **StateFlow** 来用，ViewModel 改了数据，UI 自动刷新，非常省心。”

- **亮点建议**：提到“屏幕旋转数据恢复”是 ViewModel 最经典的面试切入点。

------

### Activity 与 Fragment 的区别

- **考查意图**：考察对 Android 组件基础的理解，以及在实际项目开发中如何进行页面拆分和性能优化。
- **口语化答案**： “简单来说，**Activity 是容器，Fragment 是组件**。
  1. **角色定位**：Activity 是 Android 的四大组件之一，代表一个完整的屏幕页面，是系统调度（如 Intent 跳转）的最小单位；而 Fragment 必须依附于 Activity 存在，它是为了解决页面局部复用和在大屏（如平板）上适配而生的。
  2. **生命周期**：Activity 的生命周期由系统直接管理；Fragment 也有自己的生命周期，但它**受限于 Activity**。比如 Activity 销毁了，里面的 Fragment 肯定也跟着销毁了。而且 Fragment 的生命周期比 Activity 更复杂，多了 `onAttach`、`onCreateView` 和 `onDetach` 等阶段。
  3. **灵活性**：Fragment 可以在 Activity 运行时动态地添加、删除或替换，这比直接跳转 Activity 要轻量得多。
  4. **通信方式**：Activity 之间传参主要靠 `Intent`；Fragment 之间或者 Fragment 与 Activity 通信，现在推荐用 **ViewModel 共享数据**，或者传统的接口回调。”

------

### Activity, Fragment 与 ViewModel 关系全总结

#### 1. 核心绑定级别（ViewModel 的作用域）

ViewModel 必须绑定在一个 `ViewModelStoreOwner` 上。根据绑定的宿主不同，其作用域（Scope）分为以下四个级别：

| **绑定级别**        | **对应的 Owner**                  | **生命周期 / 存活范围**                                      |
| ------------------- | --------------------------------- | ------------------------------------------------------------ |
| **Activity 级别**   | `ComponentActivity`               | **最长**。直到 Activity 被彻底销毁（非配置更改）时结束。     |
| **Fragment 级别**   | `Fragment`                        | **中等**。直到 Fragment 被从管理器中移除（PopBackStack）时结束。 |
| **Navigation 级别** | `NavBackStackEntry`               | **灵活**。绑定在特定的导航路由上，离开该路由及其子路由时销毁。 |
| **Compose 级别**    | 最近的 `LocalViewModelStoreOwner` | 自动向上寻找最近的宿主（通常是 Activity 或导航目的地）。     |

------

#### 2. 围绕生命周期的协同关系

ViewModel 的设计初衷就是为了**比 UI 组件“活得久”**，从而解决屏幕旋转等配置更改导致的数据丢失问题。

- **配置更改（如旋转屏幕）**：
  - **Activity/Fragment**：会经历销毁并重新创建（`onDestroy` -> `onCreate`）。
  - **ViewModel**：**不会销毁**。它会留在内存中，等到新的 Activity/Fragment 实例创建后，重新与之关联。
- **真正销毁（用户点击返回键/调用 finish）**：
  - **Activity/Fragment**：进入销毁流程。
  - **ViewModel**：系统识别到宿主不再需要它，调用 `onCleared()` 方法，释放资源。

------

#### 3. 宿主与 ViewModel 的多对多关系

- **一对一（私有化）**：
  - 每个 Fragment 拥有自己的 ViewModel。
  - **场景**：处理仅属于该页面的逻辑（如：某个详情页的加载状态）。
- **多对一（数据共享）**：
  - 多个 Fragment 共享同一个 **Activity 级别**的 ViewModel。
  - **场景**：**跨页面通信**。例如“购物车”逻辑，选择页和支付页通过共享同一个 Activity ViewModel 来同步商品数量。
- **嵌套级别（父子通信）**：
  - 子 Fragment 共享父 Fragment 的 ViewModel。
  - **场景**：在一个复杂的 ViewPager 页面中，各 Tab 之间的数据联动。

------

#### 4. 技术背后的关键点

> Q: 为什么 Fragment 可以拿到 Activity 的 ViewModel？
>
> A: 因为 ViewModel 的存储库（ViewModelStore）是存在宿主里的。当 Fragment 请求 activityViewModels() 时，它其实是去“父容器”Activity 的仓库里寻找实例。

> Q: ViewModel 能持有 Activity 的引用吗？
>
> A: 绝对不能！ 因为 ViewModel 的生命周期可能比 Activity 长。如果持有 Activity 引用，当 Activity 旋转销毁时，ViewModel 还拽着它，会导致严重的内存泄漏。





在 Android 面试中，“四大组件”是绕不开的必考题。面试官通常会先让你列举它们，然后紧接着深挖它们的**生命周期**、**通信方式**以及在**性能优化**中的注意事项。

------

## 🏛️ Android 四大组件全家桶

| **组件名称**           | **核心职责**                                | **形象比喻**         |
| ---------------------- | ------------------------------------------- | -------------------- |
| **Activity**           | 负责与用户交互的**界面**。                  | 商店的**柜台**       |
| **Service**            | 负责在后台执行**耗时任务**（没有界面）。    | 商店的**后厨**       |
| **Broadcast Receiver** | 负责接收来自系统或其他 App 的**广播通知**。 | 商店的**广播大喇叭** |
| **Content Provider**   | 负责在不同应用之间**共享数据**。            | 商店的**共享仓库**   |

------

## 🛠️ 1. Activity (活动)

它是最常用的组件。面试官最爱考的是**生命周期**。

- **基本用法：** 在 `AndroidManifest.xml` 中注册，通过 `startActivity(Intent)` 启动。
- **性能优化点：** * **避免在 `onCreate` 做耗时操作：** 这会导致黑屏或启动慢。
  - **及时释放资源：** 在 `onStop` 或 `onDestroy` 中取消网络请求、解绑监听器，防止内存泄漏。

------

## ⚙️ 2. Service (服务)

Service 运行在主线程！如果你直接在里面写死循环，App 照样会 ANR（应用无响应）。

- **基本用法：** * `startService()`：一旦启动，除非手动 stop，否则一直运行。
  - `bindService()`：与启动它的组件同生共死。
- **性能优化点：** * **使用 IntentService 或协程：** 确保耗时逻辑在子线程。
  - **前台服务 (Foreground Service)：** 如果任务很重要（如音乐播放），必须展示通知，防止被系统杀掉。

------

## 📣 3. Broadcast Receiver (广播接收者)

用于监听系统事件，比如“电量低”、“网络变化”。

- **两种注册方式：**
  1. **静态注册：** 在 Manifest 里写，App 没启动也能收（Android 8.0 后限制很多）。
  2. **动态注册：** 在代码里 `registerReceiver`，**必须记得在销毁时 `unregisterReceiver`**，否则会内存泄漏。
- **性能优化点：** `onReceive` 方法里不能执行超过 10 秒的操作，否则会报 ANR。

------

## 📦 4. Content Provider (内容提供者)

它是唯一能让你的 App 数据（比如数据库、文件）被其他 App 安全访问的方式。

- **基本用法：** 通过 `ContentResolver` 进行 CRUD（增删改查）。
- **典型场景：** 读取手机通讯录、相册。
- **性能优化点：** 在跨进程通信时，尽量减少频繁的小数据查询，合并成批量操作，减少 IPC 开销。

------

## 🏁 性能优化面试实战：组件间的协作

面试官会问：**“如果我在 Activity 里开启了一个后台线程下文件，Activity 销毁了，会有什么问题？该怎么优化？”**

### 💬 口语化参考答案

“直接在 Activity 里开线程非常危险，因为 Activity 销毁后线程还在跑，不仅会**内存泄漏**，还可能因为找不到 Context 而崩溃。

**我的优化方案是：**

1. **对于简单的异步操作：** 我会使用 **ViewModel + 协程**。协程绑定了 `viewModelScope`，页面一关，任务自动取消，既干净又安全。
2. **对于需要跨页面存在的任务：** 比如下载一个几百兆的安装包，我会用 **WorkManager**（它是基于 Service 封装的）。它非常智能，即便 App 进程被杀了，它也能在网络恢复或充电时自动断点续传。这不仅保证了任务完成，还优化了系统**电量消耗**。”

------

## 💡 进阶建议

- **Intent 传输限制：** 顺带提一句，Intent 传数据不能太大（通常限制在 1MB 以内），否则会抛出 `TransactionTooLargeException`。
- **单 Activity 架构：** 提到现在流行“单 Activity + 多 Fragment”配合 **Navigation** 库，这样能减少组件创建的开销，提升启动速度。