面试是复盘和提升的最好机会。这些问题都是 Java 并发编程和安卓开发中的核心考点。我为你整理了一份既专业又易于表达的回答思路，帮助你应对后续的面试。

------

## 1. 说说对“锁”的了解

**回答思路：** 锁是解决**并发安全**问题的核心工具，主要用于控制多个线程对共享资源的访问。你可以从以下几个维度进行分类描述：

- **从锁的特性分类：**
  - **乐观锁 vs 悲观锁：** 悲观锁（如 `synchronized`）认为冲突一定会发生，所以先拿锁再操作；乐观锁（如 `CAS`）认为冲突少，更新时再检查是否有冲突。
  - **公平锁 vs 非公平锁：** 公平锁按申请顺序排队；非公平锁允许“插队”，效率通常更高（`synchronized` 是非公平的）。
  - **可重入锁：** 同一个线程可以多次获得同一把锁，防止死锁。
- **锁的升级过程：** 在 JVM 中，`synchronized` 会经历 **无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁** 的过程，这是为了平衡性能和安全性。

------

## 2. synchronized 和 Lock 的区别

**回答思路：** 这是一个经典对比题，建议从**层次、手动性、灵活性**三个方面对比：

| **特性**      | **synchronized**                    | **Lock (如 ReentrantLock)**                           |
| ------------- | ----------------------------------- | ----------------------------------------------------- |
| **存在层面**  | Java 关键字，由 JVM 实现            | 接口/类，由 JDK 代码实现                              |
| **加锁/解锁** | 自动加锁和释放，不会死锁            | 需手动 `lock()` 和 `unlock()`，通常配合 `try-finally` |
| **灵活性**    | 较差，只能同步块或方法              | 高，支持 `tryLock()`、可中断锁、超时锁                |
| **多条件**    | 只能通过 `wait/notify`              | 支持多个 `Condition`（精确唤醒）                      |
| **性能**      | Java 6 优化后，低竞争下与 Lock 持平 | 高竞争下通常表现更稳定                                |

------

## 3. 什么是乐观锁

**回答思路：** 乐观锁不是真正的“锁”，而是一种并发控制的思想。

- **核心逻辑：** 线程在操作数据时不加锁，但在**更新**时会判断在此期间有没有人改过这个数据。
- **实现方式：**
  1. **CAS (Compare And Swap)：** 包含三个操作数——内存值 V、预期值 A、新值 B。只有当 V == A 时，才把 V 改为 B。
  2. **版本号机制：** 每次更新数据时，版本号 +1。更新时检查 `version` 是否匹配。
- **优缺点：** 优点是减少了上下文切换的开销，性能高；缺点是存在 **ABA 问题**（可用 `AtomicStampedReference` 解决）以及在高并发冲突频繁时会导致大量的自旋（空转），浪费 CPU。

------

## 4. 说说线程池

**回答思路：** 线程池是为了**减少线程创建和销毁的开销**，实现资源复用。

- **核心参数 (7个)：**
  - `corePoolSize`: 核心线程数（常驻军）。
  - `maximumPoolSize`: 最大线程数。
  - `keepAliveTime` & `unit`: 非核心线程空闲存活时间。
  - `workQueue`: 任务队列（如 `LinkedBlockingQueue`）。
  - `threadFactory`: 创建线程的工厂。
  - `handler`: 拒绝策略（队列满且达到最大线程数后的处理）。
- **执行流程：**
  1. 核心线程未满 -> 创建核心线程执行。
  2. 核心线程满了 -> 放入阻塞队列。
  3. 队列满了 -> 创建非核心线程执行（直到达到最大线程数）。
  4. 达到最大线程数 -> 执行拒绝策略（默认抛异常 `AbortPolicy`）。

------

## 5. 安卓子线程回调（UI 更新）

**回答思路：** 安卓规定不能在子线程更新 UI，必须切回主线程。

- **传统方式：**
  1. **Handler：** 子线程发送 `Message` 或 `Runnable`，在主线程 `handleMessage` 中处理。
  2. **Activity.runOnUiThread / View.post：** 内部其实也是对 Handler 的封装。
- **现代/推荐方式：**
  1. **LiveData/ViewModel：** 子线程通过 `postValue` 改变数据，UI 观察者（Observer）在主线程自动收到更新。
  2. **Kotlin 协程 (Best Practice)：** 使用 `withContext(Dispatchers.Main)` 轻松切换上下文，代码从异步变同步写法。
  3. **RxJava：** 使用 `observeOn(AndroidSchedulers.mainThread())`。

> **提示：** 面试时，建议优先提到 **协程** 和 **LiveData**，这能体现你对现代安卓开发的掌握。

------



这个问题是面试中的必考基础。回答时，不仅要说出“一个连续、一个不连续”，更要从**内存结构、时间复杂度、缓存效率**这三个深度去拆解。

------

## 数组 (Array) vs 链表 (Linked List)

### 1. 核心区别对照表

| **特性**      | **数组 (Array)**                | **链表 (Linked List)**             |
| ------------- | ------------------------------- | ---------------------------------- |
| **内存分配**  | **连续**的内存空间              | **分散**的内存空间（通过指针连接） |
| **访问效率**  | **极高**：支持随机访问 $O(1)$   | **低**：需从头遍历 $O(n)$          |
| **插入/删除** | **低**：需要移动大量元素 $O(n)$ | **高**：仅需修改指针指向 $O(1)$    |
| **空间开销**  | 较小：只存储数据本身            | 较大：每个节点需额外存指针         |
| **大小固定**  | 固定（或需动态扩容/复制）       | 动态：随时申请或释放               |

------

### 2. 深度解析：为什么数组快？为什么链表慢？

#### **内存与缓存亲和性 (Cache Locality)**

这是体现你“内功”的点：

- **数组：** 因为内存连续，CPU 在读取时会利用**预取机制**，将相邻的数据一起加载进高速缓存（L1/L2 Cache）。遍历数组时，Cache Hit（缓存命中）概率极高，速度非常快。
- **链表：** 节点分散在内存各处，CPU 无法有效预取。每次访问下一个节点都可能产生 Cache Miss，需要去内存中读取，导致性能远不如数组。

#### **操作场景的选择**

- **数组适合：** 数据量基本固定、需要频繁通过下标查找数据、对读取性能要求高的场景。
- **链表适合：** 数据量动态变化剧烈、需要频繁在头部或中间插入/删除数据的场景。

------

### 3. 安卓/Java 开发中的应用

在面试中，面试官通常会顺着这个问题问你：**“既然链表插入快，为什么 Android 开发中几乎很少看到直接用 `LinkedList`？”**

**回答要点：**

1. **ArrayList 优于 LinkedList：** 即使是插入操作，由于现代 CPU 缓存机制和 `System.arraycopy()` 的高效，只有在数据量极大且频繁在**头部**插入时，`LinkedList` 才有微弱优势。
2. **内存压力：** 链表由于存在大量的 `Node` 对象（每个节点都要存 `next` 和 `prev` 指针），在安卓这种内存敏感的平台上，会造成更大的内存开销和 GC（垃圾回收）压力。
3. **替代方案：** 如果需要高效存储且内存敏感，安卓推荐使用 `SparseArray` 或 `ArrayMap`（它们内部也是基于数组实现的）。

------

下一步建议：

这个问题通常是 HashMap 考察的引子。你想了解一下 HashMap 是如何结合数组和链表（以及红黑树）来兼顾查询和插入效率的吗？