# **一：基础**

### **1：数据类型**

java都**一：基础**

**1：数据类型**

java都有那些数据类型，基本数据类型有那些，占多少字节，多少位，引用数据类型又有那些？ 

数据类型有：逻辑类boolean。文本型char。整数型byte，short，int，long。浮点型float单精度默认小数位6-7，double双精度

| 基本类型    | 字节           | 二进制位数 | 引用类型      |
| ------- | ------------ | ----- | --------- |
| boolean | 实际按1，本来是1bit | 1     | Boolean   |
| byte    | 1            | 8     | Byte      |
| char    | 2            | 16    | Character |
| short   | 2            | 16    | Short     |
| int     | 4            | 32    | Integer   |
| long    | 8            | 64    | Long      |
| float   | 4            | 32    | Float     |
| double  | 8            | 64    | Double    |

**2：封装继承多态**

java语言有几大特性，分别怎么理解？（封装继承多态的好处）

特性：**封装继承多态**

1：封装：**封装是指属性私有化**，根据需要提供get，set方法来访问属性。既隐藏具体属性和实现细节，仅对外开放接口，控制程序中属性的访问级别。

目的：**增强安全性和简化编程**，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员

2：继承：继承是指将多个相同的属性和方法提取出来，新建一个父类。Java中一个类只能继承一个父类(**单继承**)，且**只能访问权限非private的属性和方法**。子类可以**重写父类中的方法**，**命名与父类同名的属性**。

目的：**代码复用**

3：多态：多态实现分为两种，设计时多态和运行时多态。体现为父类引用变量可以指向子类对象

编译时多态：既重载，在同一个类中方法名相同而参数不同（返回值可以相同也可以不相同）

运行时多态：既重写，是子类对父类允许访问方法的实现过程进行重新编译，返回值和形参都不能改变。

**3：权限修饰符**

java中权限修饰符有那些，都能加在什么地方，分别代表什么意义

|      | public | protected | defalit(默认) | private |
| ---- | ------ | --------- | ----------- | ------- |
| 同一个类 | √      | √         | √           | √       |
| 同一个包 | √      | √         | √           | ×       |
| 子父类  | √      | √         | ×           | ×       |
| 不同包  | √      | ×         | ×           | ×       |

**4：abstract修饰符**

abstract修饰符一般来修饰类和方法，修饰类会变成抽象类，修饰方法会变成抽象方法

抽象类不能被实例化，但有自己的构造方法

抽象类中可以没有抽象方法，但包含了抽象方法的类必须要被定义成抽象类

如果子类没有实现父类中的所有抽象方法，也要被定义成抽象类

抽象类不能被final修饰，被final修饰的类无法被继承

抽象方法不能被private修饰，因为子类必须重写父类方法

抽象方法不能被static修饰，因为被static修饰可以直接通过类名调用，抽象方法没有主体

抽象方法没有方法体，一个方法没有方法体必须被定义为抽象方法

**5：final修饰符**

final修饰基本类型变量的时候，该变量不能被重写赋值

final修饰引用类型变量的时候，该变量不能重新指向其他对象

final修饰的方法为最终方法，该方法不能被重写

final修饰的类为最终类，不能被继承

**5：static修饰符**

1：申明了静态方法或者变量，值是要放在方法区的。因为方法区是一个共享数据区，不管什么变量访问它，都是同一份

2：在静态方法中不能直接访问实例方法和实例变量

3：在静态方法中不能使用this，super关键字

4：静态方法不能被abstract修饰

静态成员变量可以使用类名或者是对象进行访问，非静态成员变量只能使用对象进行访问

静态函数可以直接访问静态成员，但不能够直接访问非静态成员，非静态函数可以直接访问金泰和非静态成员。

当类被加载时，静态代码块只执行一次，类中不同的静态方法代码块按它们在类中出现的顺序被依次执行

**7：重载和重写的区别**

方法重载和重写都是实现多态的方式

重载：编译时多态，发生在同一个类中，同名的方法如果有不同的参数列表（参数类型不同，参数个数不同，可以有不同返回值类型）被视为重载

重写：运行时多态，发生在子父类中，是子类对父类允许访问方法的实现过程进行重写编译，

所以方法名，参数列表，返回值都要相同

**8：接口与抽象类**

抽象类：被abstarct关键字修饰的类为抽象类，修饰的方法为抽象方法，只有声明没有方法体 

1. 抽象类不能被实例化，只能被继承
2. 包含抽象方法的一定是抽象类，但是抽象类不一定有抽象方法
3. 抽象类中的抽象方法的修饰符只能为public或者protected，默认为public
4. 一个子类继承一个抽象类，子类必须实现父类所有父类所有抽象方法，否则子类也会被定义为抽象类
5. 抽象类可以包含属性，方法，构造方法，但是构造方法不能被实例化，主要用途是被子类调用

接口：被interface关键字修饰

1. 接口可以包含变量。（1.8之后接口是可以出现非抽象方法的default方法，静态方法）
2. 接口支持多继承
3. 一个类可以实现多个接口
4. 1.8对接口的新特性：1：（default method）允许给接口添加非抽象方法实现，但必须使用default关键字修饰，定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用，如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法。

​                                 2：（static method）使用static修饰一个方法，并提供实现，称为静态接口方法，静态接口方法只能通过接口调用

相同点：

1. 都不能被实例化
2. 接口的实现类，抽象类的子类 都只有实现了接口或抽象类中的方法后才能实例化

不同点：

1. 接口只有定义，不能有方法实现。而抽象类可以有定义与实现，方法可以在抽象类中实现
2. 一个类可以实现多个接口，但一个类只能继承一个抽象类。接口可以实现多重继承
3. 接口强调特点功能的实现，抽象类强调所属关系
4. 接口只能包含抽象方法，静态方法，默认方法，私有方法，不能为普通方法提供方法实现，而抽象类可以包含普通方法
5. 接口只能定义静态常量，不能定义普通成员变量。抽象类既可以定义普通成员变量，也可以定义静态常量
6. 接口没有构造方法，抽象类可以包含构造方法

**9：异常**

java异常体系是什么，运行时异常和编译异常有什么区别，常见的异常有那些

异常体系：Throwable是异常的超类，将异常划分为两类：Error和Exception。

Error：是程序中无法处理的错误，此类错误一般为JVM出现问题。通常由Virtual MachineError（虚拟机运行错误），NoClassDefFoundError（类定义错误）等

Exception：程序本身可以捕获的异常

1. 运行时异常：RuntimeException类及其子类表示在JVM运行期间可能出现的错误，比如（NullPointException）空指针异常，（ArrayIndexOutBoundException）数组下标越界。此类异常一般是由程序逻辑错误引起的。在程序中可以选择捕获，也可以不处理。
2. 编译时异常：除了RuntimeException及其子类之外的异常。比如（IOException），必须对该异常进行处理，否则编译不通过。

常见异常

1. ClassFormatError（类格式错误）
2. ClassCastException（类型转换异常）
3. NullPointException（空指针异常）
4. ArrayIndexOutBoundException（数组下标越绝）
5. ArrayStoreException（数组存储异常）
6. UnknownError（未知错误）
7. SQLException（操作数据库异常）
8. IOException（输入输出异常）

**10：==和equals的区别**

1. ==是操作符，equals是方法
2. 对于基本类型变量来说（short，int，long，float，double等）只能使用==，因为这些基本类没有equals方法，对于基本类型变量的比较使用==，一般是比较他们的值
3. 对于引用类型来说（如String）才有equals方法，因为String继承了Object类，equals是Object类的通用方法。对于该类对象的比较，默认情况下也就是没有重写Object类的equals方法，这时使用==和equals比较是效果是一样的。都是比较他们在内存中的地址值，但是对于某些类来说，为了满足业务需求，会存在重写equals方法的情况，这时使用equals方法比较需要看具体情况，例如String类，使用equals方法会比较它们的值。

**11：&（逻辑与）和&&（短路与）**

&会对所有的条件进行判断

&&判断第一个条件为false后，对后面的条件就不会进行判断了

**12：|（逻辑或）和||（短路或）**

|会对所有的条件进行判断

||判断第一个条件为true后，对后面的条件就不会进行判断了

**13：String可以修改本身么**

不可以

1.6中在String内部有value，offset，count这三个变量，并且没有提供set方法等公共方法来修改这些值，而且这三个变量是是被privete和final修饰的，所以一旦初始化，也就不能被改变了。

1.8时虽然内部只有value这个数组了，但是依然是被private和final修饰的，所以还是一旦初始化，也就不能被改变了。

**14：String，StringBuffer，StringBuilder的区别**

运行速度快慢为：StringBulider>StringBuffer>String

String是字符串常量，而StringBuffer和StingBuilder均为字符串变量。String对象一旦创建后该对象是不可改变的，但后两者是变量是可以更改的。

线程安全上：StringBuffer是安全的，StringBuilder是不安全的

一个StringBuffer对象在字符缓冲区被多个线程使用时，StringBuffer中很多方法带有synchronized关键字，所以可以保证线程是安全的。但StringBuilder方法则没有该关键字。

**15：valueOf和toSting的区别**

1. toString返回的是字符串，而valueOF返回的则是原对象
2. 因为toString为Object类中的public方法，严格意义上来说任何java对象都可以调用此方法，但在使用时要注意，保证Object不能为Null值，否则会抛出NullPointerException异常。
3. valueOf在内部会做非空判断

**16：大量字符串拼接用+效率高吗**

为什么？应该用什么代替？为什么？

效率为什么不高：string对象为不可变对象，因此在字符串进行操作修改时，String对象总会产生新的对象。所以性能相对较差

应该用什么代替：在多线程的要保证线程安全的情况下用StringBuffer.append。在单线程的情况下可以用StringBuilder.append。

为什么用这个代替：StingBuffer和StingBulider实现原理：与String相似，StringBuilder类也封装了一个字符数组。与Sting不同的是，它并不是final的，所以他是可以修改的。另外与String不同的是，字符数组中不一定所有位置都已经被占用，他有一个实例变量，表示数组中已经使用的字符个数。该类继承了abstractStringBuilder类，其append 方法会直接拷贝字符串到内部字符数组中，如果字符数组长度不够，会进行扩展。

**17：创建一个类的实例有哪些方式**

1. 用new语句创建对象
2. 运用反射，调用Class或者Constructor类的newInstance（）实例方法
3. 调用对象clone方法
4. 运用反序列手段，调用ObjectInputStream对象的readObject方法

**18：java集合体系**

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCEb4f2eddcc88b06c5e39c07a33437523b/1280)

单列集合Collection为超类，下面有List，Queue，Set

双列集合Map为超类，下面有TreeMap，HashMap

**19：List：有序，可重复**

1：ArrayList    优点：底层结构是数组，查询快，增删慢

​                        缺点：线程不安全，效率高

2：Vector        优点：底层结构是数组，查询快，增删慢

​                        缺点： 线程安全，效率低

3：LinkedList  优点：底层数据结构是链表，查询慢，增删快

​                        缺点：线程不安全，效率高

**20：set：无序，唯一**

1：HashSet    底层数据结构是哈希表（无序，唯一）

如何保证元素唯一性？ 依赖两个方法 HashCode和equals

2：LinkedHashSet   底层数据结构是链表和哈希表（FIFO插入有序，唯一）

由链表保证元素有序

由哈希保证元素唯一

3： TreeSet   底层数据结构是红黑树（唯一，有序）

如何保证元素排序？ 自然排序，比较器排序

如何保证元素唯一？ 根据比较的返回值是否是0来决定

**21：Map:双列集合**

Map为	超类，下面三个实现类分别是HashMap，TreeMap，HashTebel

1： HashMap  底层用哈希表，数据结构（链表+数组+（JDK1.8加入了红黑树）），允许Null值与Null键，键值唯一，但存取无序

如果是自定义对象需要重写HashCode和equals方法

JDK1.8之后的优化

生成了一个entry初始化容量16的数组+链表的结构，使用容量大于0.75时，自动扩容2*n 

HashMap加入红黑树结构，当链表长度达到8或容器达到64时会自动转换为红黑树储存，用以提升元素操作性能。

为什么加载因子为0.75：当加载因子设置比较大，扩容的门槛提高，频率降低，占用空间较小，但是发生Hash冲突的几率会增大。当加载因子较小，扩容门槛降低因此会占用更多空间。但储存的元素比较稀疏，发生Hash冲突可能性变小，所有综合以上取了0.5-1.0的中间值

2：LinkedHashMap   继承了HashMap，底层使用哈希表和链表实现，元素唯一有序

3：HashTebel  底层用数组+链表，不允许Null作为key和value，线程是安全的

4：TreeMap   数据结构红黑树，元素唯一且能按照给定的规则排序，键值唯一，允许Null键值

**22：红黑树**

特征：任意一个节点所包含的键值，大于左边的键值，小于右边的键值

特点：

1. 每个节点必须是红色或者是黑色
2. 根节点必须是黑色
3. 红色的节点，他的叶节点只能是黑色
4. 从任意节点到其每个叶子节点的所有路径都包含相同数量的黑色节点

依靠左旋和右旋保持平衡

**23：concurrentHashMap**

原理是什么？

ConcurrentHashMap的锁分段技术：因为HashTable的线程都必须去竞争同一把锁，导致线程效率低下，从而诞生了ConcurretHashMap锁分段技术，简洁的来说就是：假如容器中有多吧锁，每一把锁用于锁容器中的一部分数据，那么当多个线程访问容器中不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率。首先将数据分成一段一段，然后给每一份数据加上一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问。不能用整个ConcurrentHashMap加锁。

**24：Socket是什么**

首先我们要知道，IP对应网络层，TCP对应传输层，HTTP对应应用层

IP/TCP的协议时传输层协议，主要解决数据如何在网络中传输，而HTTP则是应用层协议，主要解决如何包装数据

**Socket实际上就是对IP\TCP协议的封装**，他的出现只是为了让程序员更方便的使用TCP\IP协议栈而已，Socket本身并不是协议，**他是应用层与TCP\IP协议通讯的中间抽象层，是一组调用接口。**

应用程序可以通过它来发送或者接收数据，可对其像文件一样的打开，读写，关闭等操作。

套接字允许程序将I/O插入到网络中，并与网络中的其他应用程序进行通讯。网络套接字是IP地址与端口的组合。

**25：IO/NIO/BIO/AIO是什么**

先了解什么时同步异步，阻塞与非阻塞

同步：就是发起一个请求调用后，被调用者未处理完成请求之前，调用不返回。

异步：就是发起一个请求后，立刻得到被调用者的回应表示已收到请求，但是并不会返回被调用结果。被调用者会通过回调机制来通知调用者其返回结果。

阻塞：阻塞就是发起一个请求，调用者一直等待结果返回。也就是当前线程会被挂起，无法从事其他任务。只有当条件允许之后才能继续。

非阻塞：就是发起一个请求，调用者不用一直等待结果返回，可以先去干其他事。

IO：为阻塞IO

BIO：为同步阻塞IO，吞吐量低，可靠性非常差。服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务器需要启动一个线程进行处理。

NIO：同步非阻塞IO，吞吐量中，可靠性差。服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。用户进程也需要时不时询问IO操作是否就绪。NIO三个核心概念，缓冲区，通道，选择器。

AIO：异步非阻塞IO，吞吐量高，可靠性高。在读写操作结束之前，允许进行其他操作的IO处理

**26：反射**

什么是反射？

java在运行状态下，对于任意一个类，我们能知道这个类的属性和方法，对于一个任意一个对象我们能够调用它的属性和方法。这个动态获取信息和动态调用对象为反射机制。

有什么用？

在已知反射能够在运行时能够动态获取信息和动态调用对象，那么我们可以更灵活的编写代码，代码可以在运行的时候装配，无序在组件之间进行源代码链接，降低代码的耦合度，还有动态代理实现等等。

使用场景？

1. 模块化开发，通过反射去调用字节码文件
2. 动态代理设计模式也是采用反射
3. spring框架，sping通过xml配置模式状态Bean：将程序内的所有的xml或Properties配置文件加载入内存，java解析配置文件，得到里面的对应实体类的属性信息，然后利用反射机制根据这个字符串获得某个类的Class实例，然后在动态配置实例的属性
4. JDBC数据库连接，通过Class.forName加载数据区的驱动程序，（这一步是通过反射加载的），然后在通过DriverManager类进行数据库连接。在通过Connerction接口接收连接。

什么是暴力反射？

如果构造方法，普通方法，字段被private（私有）修饰，默认该类的外部是不允许访问的。

但是如果使用暴力反射的话，即使被private修饰也可以进行操作

原理：假设定义了一个A类和B类，A类里面有一个public字段和private字段，在B类里面new了一个A类的一个实例，这个时候我们可以通过反射获取a引用对象的共有字段，但A类其中有一个私有字段，我们无法获取，这时就要用到暴力反射，通过实例a的getClass方法，先获取到a所属类的字节码，然后调用getDeclaredField（私有字段变量名）获取A类所有字段，包括私有，此时虽然我们已经获取到了私有字段，但是无法查看私有字段的值，这个时候就要用到setAccessible（true）方法来暂时改变字段的私有特性，然后我们就可以使用get方法获取到A类私有字段的值了

27：算法

冒泡排序：这是一种最简单最直观的排序算法，将数列依据你指定的模样排序，例如左小右大它需要重复走访要排序的数列，一次比较两个元素的值，，在比较时如果发现他们的顺序错误就会将他们交换过来。对每一组相邻元素都会重复同样的动作，这步做完最后的元素将会是最大的值，之后在重复以上步骤，除了最后一个，持续对越来越少的元素重复以上步骤，直到没有一对元素需要比较。

选择排序：和冒泡类似，但是冒泡时通过相邻的两个元素进行比较，而选择排序则是通过对整体的选择，每一趟从前往后找，找出无序区的最大值或最小值，再将这个值交换到无序区的最前方。

快速排序：选数列的一个数作为基数，一般是数列的第一个数作作为基数L，然后在选数列的最后一个数作为R，大于基数的放右边，小于基数的放左边，然后重复进行操作。

**27：JDK1.8新特性**

lambda表达式：

作用：用于简化创建匿名内部类对象，表达式的代码块用于实现抽象方法的方法体，就相当于一个匿名方法。

组成：形参列表，箭头，代码块

Lambda表达式的目标类型必须是函数式接口，（函数式接口代表只包含一个抽象方法的接口），使用Lambda表达式可以使代码变得更加简洁，紧凑。

Stream流：

什么是Stream流：Stream流是一个来自数据源的元素队列并支持聚合操作

数据源：流的来源，可以是集合，IO，数组

聚合操作：类似SQL语句一样的操作，比如filter，limit，map，find

API：forEach：用来迭代流中的每个数据

​         map：用于映射每个元素对应的结果

​         filter：用于通过设置条件来过滤元素

​         limit：用于获取指定数量的流

​         sorted：用于对流进行排序

**28：IO流**

什么是IO流：

IO：输入（Input）/输出（Output）

流：是一种抽象概念，是对数据传输的总称。

IO流就是用来处理设备间数据传输问题的，例如：文件复制，上传，下载

分类：

按照数据流向：输入流：读数据

​                         输出流：写数据

按照数据类型：字节流，字符流

使用场景：如果是纯文本操作优先使用字符流，如果是图片，视频等二进制文件用字节流

字节类：

InputStream：这个抽象类是所有字节输入流的超类

OutputStream：这个抽象类是所有字节输出流的超类

字符流：

Reader：是所有字符输入流的父类

Wirter：是所有字符输出流的父类

**29：分布式主键自增**

uuid：

优点：代码简单，直接调用API即可

缺点：无法排序，无法保证递增趋势。id存储空间相对较大

数据库自增：

优点：代码简单

缺点：不同数据实现方式不同，当数据库迁移时也需要做一些迁移。如果是单体架构，可能会出现单点故障问题。

redis生成自增id

优点：不依赖数据库，相对性能较高

缺点：如果项目中没有使用到redis需要额外加入组件，会增加系统复杂度

雪花算法：

优点：代码简单，可以利用Hutool工具

缺点：可能存在时钟回拨的问题

组成：

四部分组成，第一部分是第1位bit始终为0，保证这个ID为正数，

​                      第二部分是41位bit的时间戳可以精确到毫秒

​                      第三部分是10位bit组成的机器id，

​                                    其中10bit组成的机器id中，有5bit代表的是机房，5bit代表的是机器，总支持1024台机器

​                      第四部分是12位bit的一个计数序列号

​                                     这个是用来记录同一秒内产生不同的id。

​                                     12bit字节代表的是最大整数2的12次方，所以在一秒内可以产生4096个id。如果并发超过4096是不会有id重复问题，通过源码我们可以看到，如果他超过了这个最大值4096，它会阻塞，阻塞到下一秒在生成新的id

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE980600c458deca032eca1224112ce43a/2130)

**二：JVM**

**1：JRE和JDK的区别**

JRE：是java运行时的环境，包含了java虚拟机，java基础类库。是java程序运行所需要的软件环境，面向的是java程序使用者

JDK：是java开发工具包，是java程序所需的开发工具包，面向的是程序员。。

JDK包含了JRE，JRE包含了JVM

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE04c892ec2e97c6b9a3bffacbe63dc552/2199)

**2：JVM内存模型是什么样**

内存结构根据线程数据共享分两块

线程隔离私有数据区：

​                                 程序计数器，线程栈，本地方法栈

线程共享数据区：

​                          堆，方法区

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE36271fb0fd277b0ef7525dc9d7ed3292/2201)

**3：JVM双亲委派加载机制**

什么是双亲委派机制？

在知道双亲委派机制之前我们要先知道类加载器的作用

启动类加载器负责加载java_HOME目录下bli目录下的类库

扩展类加载器负责加载java_HOME目录下bli目录下的ext的子目录下的类库

应用程序类加载器负责加载用户路径Class.path上的类库就是我们写的程序大部分在这里加载

自定义加载器通过继承ClassLoader根据不同需求来实现自定义的类加载器

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE38918ef6897016115e582f6eff3494bd/2219)

工作过程：1：类加载器收到类加载请求

​                  2：把这个请求委托给父类加载器去完成，一直向上委托，直到启动类加载器

​                  3：启动类加载器检测能不能加载（利用findClass方法），能加载就结束，不能加载就会抛出异常交给子类加载器去加载。

​                  4：重复步骤三，但是一旦到自定义加载器还无法加载时，就会抛出ClassNotFound的异常

为什么JVM这么做？

JVM是根据全限定名来加载类的，如果出现两个或者多个全限定名完全一直的情况下，该选择加载哪个类，这就是双亲委派机制要做的事

有违反双亲委派的例子吗？

1. 在1.2之前，用户直接调用LoadClass方法。后改成FindClass方法，JVM官方推荐重写FindClass方法，而不是LoadClass方法，这样就依然可以符合双亲委派模型
2. 在操作数据库时，java提供接口，规范给数据库厂商，数据库厂商按照接口，规范自己实现自己的类库，在点进DriverManager源码会发现Drivermanager会主动对第三方Driver进行加载，扫描到java.sql.Driver类型的第三方类就使用ServiceLoader进行加载，而ServiceLoader内部则是使用当前线程Context的类加载器，一般线程Context加载器默认为Application类加载器加载，所以当前这个类加载器可以被正常加载了。

**4：类加载的流程**

类加载的流程分为7步：加载>验证>准备>解析>初始化>使用>卸载

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCEa1d3d6f23dd18a66eaed932f94679fcf/2354)

加载：把代码数据加载进入内存中

验证：当JVM加载完Class文件后并在方法区创建相对应的Class对象，JVM便会启动对该字节             码的校验，只有符合JVM字节码规范的文件才会被	JVM正确执行

准备：当字节码文件校验后，JVM便会开始对类变量分配内存并初始化

解析：通过准备阶段后，JVM会针对类或接口，字段，类方法，接口方法，方法类型，方法句柄和调用限定符好7类引用进行解析。

初始化：JVM会根据语句循序对类对象进行初始化，触发初始化的五种情况

​             1：遇到New，getStatic，putStatic，invokeStatic

​             2：使用java.lang.refiect包的方法对类进行发射调用的时候

​             3：初始化一个类的时候，如果父类还没有初始化，需要先触发父类初始化

​             4：虚拟机启动，用户需要指定一个执行的类（main方法的类）会初始化该类

​             5：当使用JDK1.7动态语言支持时如果MethodHandle实例解析结果对应的方法句柄的类还未初始化时，会优先触发该类的初始化。

使用：完成初始化后，JVM便从入口方法开始执行用户的程序代码

卸载：当用户程序执行完毕后，JVM便开始销毁创建的Class对象最后负责的JVM也退出内存

**5：GC的主要区域和GC机制**

JVM的GC的主要区域以及各自的GC机制是什么样的？

GC的主要区域：主要区域在堆和方法区

各自的GC机制：

​                        堆的GC机制：为了方便对象管理，内存分配，和GC堆分为新生代和老年代比例为1：2

​                        1）新生代：大部分new对象在此区域：包含Eden区+Survicor From区+Survicor To区 三个区的比例为 8：1：1

​                                          算法：当Eden区满了之后会触发一次GC，触发后会将还存活的对象从Eden区+from区/To区中用copy复制算法转移至from区/to区。这时还存活下来的对象会MG次数+1，当对象MG次数大于15时，该对象会移至老年去

​                        2）老年代：新生代经过15次GC之后的对象和新生代区存不下，比较大的对象会存在此区域

​                                          算法：当老年代没有内存空间容纳新对象时，会触发一次FC。首先Stop the World 暂停GC回收线程外额所有线程。然后使用标记—清除/整理算法，标出所有可以访问的对象并做个指定标记，之后便利堆内存，把未标记的对象进行回收。在此处标记可访问对象时还用到了可达性算法

​                                            可达性算法（GC Root）：从根节点出发，给所有可达对象做标记，解决了引用计数法对象相互依赖而无法被回收的问题。

​                                            标记—清除算法：效率较高，但是最后得到内存空间不是连续的

​                                            标记—整理算法：效率较低，但是最后得到内存空间时连续的

​                       方法区GC机制：这里主要存放运行常量池，静态变量，类信息，JTT编译后的代码等数据

​                       方法去的GC触发条件十分苛刻，必须符合以下三点才会被回收

​                             1）所有实例被回收

​                             2）加载该类的ClassLoader被回收

​                             3）Class对象无法通过任何途径访问，包括反射

**6：JVM的GC算法都有哪些？**

确定垃圾算法：

1. 引用计数发：每被引用一次，引用次数+1。无法解决互相依赖引用而无法被问题
2. 可达性算法（GC Root）：从根节点触发，给所有可达对象打上标记。可以解决互相依赖引用而无法被问题

垃圾清除算法：

1. 标记清除：效率较高，但是最后得到内存空间不是连续的
2. 标记整理算法：效率较低，但是最后得到内存空间时连续的
3. 复制算法：将内存分为两块，每次只使用一块，回收时将存活对象复制到另一块中，简单高效，但是浪费内存空间。

**三：spring&boot&MVC**

**1：SpringIOC，控制反转**

SpringIOC即控制反转不是一种基数，是一种思想，是一种面向对象编程的重要法则，IOC意味着将你设计好的对象交给容器管理，而不是传统的在你的对象内部直接控制，这种思想他能使我们设计出松耦合，更优良的程序。

何为反转；有反转就有正转：

正转：传统的应用程序是由我们自己在对象中主动控制去直接获取依赖对象

反转：是由容器帮我们查找及注册依赖对象，对象只是对被的接收依赖对象。

IOC对编程最大的改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，想要获取什么资源都是主动出击，但是在IOC中应用程序就变为被动了，被动等待IOC容器来创建并注入他所需要的资源

**2：spirng Bean的生命周期**

Bean的生命周期分四阶段

1. 实例化 Instantiation
2. 属性赋值  Populate
3. 初始化  Initialization
4. 销毁  destruction

实例化和属性赋值是对应的构造方法和Setter方法的注入，初始化和销毁是用户能自定义扩展的两个阶段

**3：IOC循环依赖问题**

什么是循环依赖：A依赖B B依赖A 就是循环依赖，当IOC都到A配置时，会先去实例化A，然后发现A依赖B，又去实例化B，结果又发现B依赖A，又会去实例化A，如果不解决循环依赖，容器就会无线执行上面的流程，直到内存溢出

知道什么是循环依赖后，我们首先要从Spring Bean的生命周期开始说，首先在sping Framework体系中我们的一个Bean它有一个BeanDefinition来构建的，（BeanDefinition可以理解为我们Sping的一个建模），springBean的生命周期大体分为以下几步，spirng容器启动扫描把类变成我们的BeanDefinition存到我们的beanDefinitionMap中，然后进行遍历，遍历完成后对我们的beanDefinition做一些基本的验证，是否单例，是否抽象是否懒加载，验证完成后他开始要实例化bean之前会去容器中就是我们的spring单例池当中获取一遍，看这个bean存不存在，如果不存在，再去看一下它有没有存在我们的二级缓存中（就是有没有提前被暴露）如果都没有代码会接着往下执行，创建A对象（如何创建：首先会去推断构造方法，把当前Spring Bean类当中的构造方法得到一个最佳的构造方法，推断完成后会通过反射去实例化一个java对象），创建对象后，会对该对象做一些初始化工作，（比如说是否要对这个Bean做一些BeanDefinition的合并，spring容器是否支持循环依赖，如果支持循环依赖会提前暴露一个当前java对象，也就是半成品所对应的ObjectFactory一个工厂类，把这个工厂类暴露。这个暴露就是会存到一个二级级缓存的Map当中）（属性填充，提前暴露）在填充属性当中，会发现A依赖B，这时会走B的生命周期流程，首先会对B做验证，判断B有无在单例池中，如果没有，会在判断B是否提前暴露，这时B肯定是没有提前暴露的，B也是会往下执行，B将会实例化，实例化之后会对B做一个初始化工作（把B提前暴露，属性填充）当B做属性填充时，发现B要填充A，但是此时A并没有被完整的实例化，所有并不能去填充A。所以此时要走一边获取A或者说创建A的流程，那么又会走刚刚之前走过一边第一次的A流程，在走A流程的过程当中，spring会发掘A已经提前暴露所有B能够拿到我们一个已经提前暴露好的ObjectFactory所产生的一个A对象，这样就完成了循环依赖（在此我们可以发现循环依赖时只默认支持单例的）

**三级缓存**

/** Cache of singleton objects: bean name --> bean instance */

private final Map singletonObjects = new ConcurrentHashMap(256);

/** Cache of early singleton objects: bean name --> bean instance */

private final Map earlySingletonObjects = new HashMap(16);

/** Cache of singleton factories: bean name --> ObjectFactory */

private final Map> singletonFactories = new HashMap>(16);

一级缓存：单例对象缓存：当Bean已经被实例化、初始化之后，也就是完全创建完成后，会放入singletonObjects。

二级缓存：早期单例对象缓存：它是一个中间的过渡缓存，保存已经被实例化，但没有被属性注入的早期暴露Bean。 当Bean没有完全创建完成时，一级缓存中当然没有，尝试二级缓存中获取，如果二级缓存中没有，但是在三级缓存中有此Bean的创建工厂，意味着可以得到这个Bean的早期暴露对象，将Bean的工厂从三级缓存中移除，放入二级缓存中。

三级缓存：单例工厂缓存 ：它保存的是可以创建Bean的工厂。

**4：AOP的理解，场景，底层**

理解：AOP意思为，面向切面编程，通过预编译的方式和运行期间动态代理实现程序功能统一维护的一种技术，是Spring框架中的一个重要内容，是函数式编程的一种衍生范型，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可用性，同时提高了开发效率。

五种通知类型：

1. 前置通知：Before advice 在连接点之前执行，前置通知不会影响连接点的执行，除非抛出异常
2. 正常返回通知：After returuing advice 在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行
3. 异常返回通知：After throwing advice 在连接点抛出异常后执行
4. 返回通知：After advice 在连接点执行完成后执行，不管是否抛出异常，都会执行返回通知中的内容
5. 环绕通知：Around advice 环绕通知围绕在连接点前后，比如一个方法调用前后。这是最强大的通知类型，能在方法调用前后自定义一些操作。

场景：

1. 记录日志
2. 监控方法运行时间
3. 权限控制
4. 缓存优化，例如第一次调用时查数据库，将结果存入Redis，第二次调用时直接从redis返回对象
5. 事务管理，调用方法前开启事务，调用方法后提交关闭事务

底层：JDK动态代理，Cglib动态代理

要谅解AOP底层的两种动态代理首先要搞清楚什么是动态代理，动态代理用简洁的话说就是本来是我自己该做的事情，却请了别人来做，被请的人就是代理对象。例如春节回家要买车票，我请了我朋友帮我代买，我朋友就是代理对象。所以动态代理本质就是通过反射来产生一个代理对象

在java.lang.refiect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个接口就可以生成动态代理对象，JDK提供的代理只能针对接口做动态代理，而Cgbiib动态代理则更为强大，它可以对任意类生成代理对象，它的原理就是对目标对象进行继承代理。但如果目标对象被final修饰，那么该类无法被Cgblib代理

在AOP中如果被代理对象实现了接口，就会优先使用JDK代理，如果没有就会使用Cgblib代理

**5：MVC的工作流程**

1. 用户发送请求至DispatcherServlet
2. DispatcherServlet收到请求调用HandlerMapping
3. HandlerMapping根据URL找到具体的处理器，生成处理器执行链（HandlerExcutionChain），里面包括了处理器拦截器（HandlerIntercepter）处理器对象（Handler）。一并返回给DispatcherServlet
4. DispatcherServlet根据Handler获取处理器适配器（HandlerAdapter），执行HandlerApdapter处理一系列操作，如参数封装，数据类型格式转换，数据验证等操作
5. HandleAdapter执行Handler完成后返回ModelAndView给DispatcherServlet
6. DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）
7. ViewReslover执行后返回具体View给DispatcherServlet
8. DispatcherServlet对View进行视图渲染，（将Model填充至VIew中）
9. 响应客户

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCEabb23bb22823be89adf2ed96267e6a3a/3098)

**6：Spring事务的理解，隔离级别，传播行为，事务失效**

理解：Spring事务本质上就是数据库对事务的支持，没有数据库的支持，Spirng是无法提供事务功能的

事务特性ACID：原子性（Atomicity）要么全完成要么全失败

​                           一致性（Consistency）不管成功或失败，都要确保所属业务处于一致的状态

​                          隔离性（Isolation）每个事务都会隔离开来，防止数据损坏

​                          持久性（Durability）一旦完成，无论发生什么系统错误，结果都会不受影响，事务的结果会写到持久化容器中

隔离级别:

关于事务的并发可能出现的问题

1.脏读：一个事务读到另一个事务未提交的更新数据。 2.不可重复读：一个事务两次读同一行数据，可是这两次读到的数据不一样。 3.幻读：一个事务执行两次查询，但第二次查询比第一次查询多出了一些数据行。

| 事务隔离级别                 | 脏读   | 不可重复读 | 幻读   |
| ---------------------- | ---- | ----- | ---- |
| 读未提交（read-uncommitted） | 是    | 是     | 是    |
| 不可重复读（read-committed）  | 否    | 是     | 是    |
| 可重复读（repeatable-read）  | 否    | 否     | 是    |
| 串行化（serializable）      | 否    | 否     | 否    |

传播行为

1. propagation_required(需要)：spring事务默认传播行为，如果存在事务则加入，不存在则创建新的
2. propagetion_supports(支持)：存在事务则加入，不存在则以非事务方式运行
3. propagation_mandatory(强制)：存在则加入，不存在抛出异常
4. propagation_requires new （新建需要）新建一个新的事务，如果当前存在事务，延缓当前事务
5. propagation_NOT_supported(不支持)以非事务状态运行，如果当前存在事务，暂停当前事务
6. propagation_never(从不)以事务状态运行，如果当前存在事务，则抛出异常
7. propagation_nested(嵌套)如果没有就新建，如果有就在当前事务中嵌套一个事务

事务失效

1. 未启用Spirng事务管理：要在启动类打上@EnableTransactionMangement注解
2. 方法不是Public类型，如果@Transaction用在了非Public方法上将失效
3. 数据源未配置管理，Spirng是通过事务管理来管理事务，不要忘记配置事务管理器，每个数据源都要配置
4. 自身调用问题，必须通过代理对象访问方法，事务才会生效。如果是用的this显然事务是会失效的
5. 异常类型错误，并不是所有异常Spring都会回滚事务，默认情况下只有RuntimeException和Error的情况下Sping才会回滚事务，当然我们也可以自定义回滚的异常
6. 异常被吞了，如果方法内部用了Try catch方法自己将异常给处理了，事务就不会回滚了
7. 业务和Spring事务必须同一线程

**7：Spring核心注解及其作用**

1. Controller：在控制层表示该类是SpringMVC Controller处理器
2. Service；在业务逻辑层使用，标注这是业务层组件
3. Componnet：标注在一个类上，表示为Spring容器中的一个Bean
4. Aotuwried：把配置好的Bean完成属性，方法的组装，完成自动装配的工作
5. bean：意思是产生一个bean交给Spring容器管理
6. Configuration：声明当前为配置类
7. ComponnetScan：对Componnet组件进行扫描
8. Value：为对应的属性注入值 

**8：Spring和SpringBoot关系**

SpringBoot只是对spring本身的拓展，消除了设置Spring应用程序所需的大量XML配置，使开发，测试，部署更加方便

**9：SpringBoot自动装配原理**

1. 在springApplication里面里面有个EnableAutoConfiguration注解。这个注解就是实现自动装配的注解
2. 在这个注解里面可以发现有一个@Import导入了一个配置类AutoConfigurationImportSelector
3. AutoConfigurationImportSelector配置类里面有个LoadFactoryNameS方法，这个方法的作用就是来读取包中/项目中META—INF/Spring.factories文件
4. Spring.factories配置了自动装配类，比如以德鲁伊为例，在里面就会有DruidDateSourceAutoConfiguretion这个自动装配类，这个类里面会根据条件去创建Bean。

**10：SpringBoot核心注解**

SpringBoot最最最核心的注解是@SpringBootApplication，在SpringBoot启动类上标识这是一个SpringBoot项目，用来开启SpringBoot的各项能力，其中这个注解又包含了三个核心注解，@SpringBootConfiguration

@EnableAutoConfiguration，@CompnentScan

@SpringBootConfiguration 这个注解就是Configuration的变体，用来装饰springBoot的配置，装配所有的Bean事务，提供Spring的上下文环境

@EnableAutoConfiuration 这个注解是SpringBoot自动装配注解，开启这个注解后SpringBoot能根据当前类路径下的包或者是类来配置spingBean

@CompnentScan 这个注解是SpringBoot3.1之后才添加的，用来代替配置文件中的Compnent—scan来开启组件扫描，可自动发现和装配Bean，即自动扫描包路径下的@Compnent进行Bean实例化到context

**11：SpringBoot启动流程**

1. 初始化配置，通过ClassLoader，LoderFactories读取classpath下所有的Sping.factories配置文件，创建一些初始化配置对象，通知监听者应用程序启动开始，创建环境对象environment，用于读取环境配置，例如：Application.yml
2. 创建应用程序上下文，CreateApplicationContext，创建beam工厂对象
3. 配置工厂对象，包括上下文ClassLoader ，对象发布处理器，BeanFactoryPostProcessor（发布处理器）
4. 注册并实例化BeanFactoryPostProcessor，并且调用这些处理器，对包扫描解析
5. 注册并实例化BeanPostProcssor
6. 初始化一些与上下文特别有关系的bean对象，默认的Tomcat服务器创建就是在此方法完成（onRefresh），此处定义特别的Bean创建，一般是服务器有关或者个性化的对象
7. 实例化所有Bean工厂缓存的Bean对象
8. 发布通知，通知上下文刷新，启动Tomcat服务器
9. 通知监听者，启动程序完成

**12：SpringBoot读取配置文件的方式**

1. 使用@Value注解，这个注解默认读取的是Application文件
2. 使用Environment读取文件，只需要在类中注入Enviroment，就能读到相关配置
3. 使用@ConfigurationProperties注解，当项目变量比较多的时候用以上两种比较繁琐，这个时候通常就会用ConfigurationProperties，将Properties属性和Bean关联在一起，只需要注解就可以读取到配置文件属性记得要用perfix来指定读取前缀

**13：自定义Spirng Starter**

1. 创建一个Spring Boot项目，在POM文件导入相关依赖
2. 删除启动类，resources下的文件，test文件
3. 编写Properties属性，用于读取属性
4. 创建配置类
5. 创建自动配置类
6. 在resources文件下新建一个META-INF文件，并在下面创建Spring.factories文件，将配置类进行注册
7. 执行mav clean install将项目打成Jar包即可

**四：Mysql&Mybatis**

**1：什么是索引**

索引的本质是帮助sql高效获取数据的数据结构，Mysql主要应用的索引数据结构为B+tree

**2、Mysql的数据结构？为什么用这种结构？提高磁盘IO效率**

Mysql的数据结构为B+tree

由于数据存储与物理磁盘我们要尽量减少IO的次数，才能有效提高查询效率。

1. B+数的非叶子节点存放的都是主键，主键占用空间少，每个节点能存放的主键就能够，能有效的降低树高，从而减少IO次数
2. 磁盘预读，预读的长度一般为page的倍数



**3、数据IO的查找流程？**

1：对于聚集索引（主键索引）来说，也就是通过主键查询，一次查询就能查询到具体的行数据信息

2：对于非聚集索引（唯一索引，普通索引，全文索引）来说

​             如果需要查询的数据列在索引中，如A+B联合索引，根据A去查询B，则通过一次查询就能直接拿到索引上的数据，也就覆盖索引的现象

​             如果需要查询的数据列不在索引中，则需要去普通索引数中进行第一次查询得到行数据的主键值，然后通过主键值去主键索引库中第二次搜索得到真实数据，这种需要二次查询的现象叫回表查询



**4、B+tree和Btree组成？异同**

B+tree和Btree都是由叶子节点和非叶子节点组成的

异同：

1. B+tree是Btree的变体
2. B+tree在Btree的基础上增加了叶子结点间的顺时针访问指针
3. B+tree每个结点的指针上限为2d，Btree每个结点的指针上限为2d+1
4. B+tree非叶子结点只储存索引值，叶子结点储存真实数据。而Btree所有结点上都储存数据



**5、InnoDB和Mysiam的区别？**

这两种引擎B+tree的叶子结点和非叶子结点分别存储的什么？

区别：Mysiam的索引和数据分两个文件夹进行储存，MYI文件储存索引，MYD文件储存数据，所以Mysiam的B+数只储存了索引key值地址，而真正的数据是储存到MYD文件的。

叶子结点储存数据地址值，非叶子结点储存索引值

​           InnoDB的索引和数据都储存在一个文件，ibd文件，所以能知道InnoDB储存引擎中的B+数既储存了索引又储存了数据

叶子结点储存真实数据，非叶子结点储存索引值



**6、Mysql索引有哪些类型？**

什么场景使用哪种索引？

按类型分有聚集索引（主键索引）和非聚集索引

主键索引：是特殊的唯一索引，一个表只能有一个主键键，不允许由空值，

普通索引：普通索引是最基本的索引，他没有任何限制，值可以为空

唯一索引：索引列的值可以为空，但是必须唯一，如果是组合索引，则列值的组合必须唯一

组合索引：是在多个字段上创建索引，只有在查询条件中使用了创建索引的第一个字段，索引才会被使用，使用组合索引时要遵循最左前缀集合

全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。



**7、如何进行Mysql优化？**

（sql优化层面和服务器优化层面）

sql优化：

1：不要使用select * 去查询

2：规范大小写，sql是有缓存，避免每次都要解析

3：使用exsits代替in，更加高效

4：mysql sql解析的时候时从右到左（从下到上）原则，基于这个原则from后面能过滤掉更多数据的基础表放后面，where后面能过滤掉跟多数据的查询条件放后面

5：查询条件中用相同类型去查，避免数值列用字符串查询条件

6：合理使用索引：1：为合适的列添加索引           

​                               2：尽量建立联合索引，也节省空间成本             

​                               3：尽量建立覆盖索引         

​                               4：要去避免会使索引失效的操作，比如：索引列有Null。

​                                                                                              ：使用负向查询not，not in，not like

​                                                                                              ：like将%放左边

​                                                                                              ：建立联合索引要遵循最左匹配机制

7：explain命令进行慢查询排查，这是查询之后的具体信息：

​                        1：id：select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的循序，当id相同，执行顺序从上到下。id值越大优先级越高，越先执行

​                        2：select_type：查询类型。有simple，primary，subquery（子查询），derived，union，union result 

​                        3：table：正在访问那个表

​                        4：partitions：匹配的分区

​                        5：type：访问的类型，效率从快到慢：        null>system>const>eq_ref>ref>ref_or_null>index_merge>range>index>ALL

​                        6：possible_keys：显示可能应用在该表中的索引

​                        7：key：实际使用到的索引，如果时null，则没有索引

​                        8：key_len：表示索引中使用的字节数，可以通过该列计算查询中使用的索引长度

​                        9：ref：显示索引的那一列被使用了

​                        10：rows：根据表统计信息及索引选取情况，大致估算出找到所需记录所读取的行数，这个值越小越好

​                        11：filtered：查询的表行占表的百分比

​                        12：extra：包含不适合在其他列中显示十分重要的额外信息

服务器优化：

1：读写分离：主节点写，从节点读

2：分库：根据业务或者其他维度把数据存放到不同的数据库

3：分表：1：水平分表：字段都一样，分多张表存放不同时间范围或不同维度的数据，实时数据，历史数据

​                2：垂直分表：将不同字段放在多张表，使用外键关联

​                 常用分库分表工具Mycat



**8、Sql调优从何入手（措施）**

调优无非就两点，减少响应时间（减少数据库每个增删改查操作的执行时间）

​                             提高吞吐量（提高数据库单位时间内能够执行操作的数量）

从三个维度进行优化：

客户端优化：sql语句：通常业务中最常见的就是sql查询速度慢的问题，这个需要我们用expiain去排查慢查询问题

服务端优化：Mysql配置：mysql配置文件中支持很多配置选项，同时很多重要配置也帮助我们设置了默认值，通常时无需修改就可以正常部署，但是这也代表这默认配置并不是适合当前项目及系统的最佳配置。

架构层优化：表结构和存储引擎：我们都知道数据库表结构设计对于业务来说时非常重要的，良好的表结构设计时高性能的基石，同时Mysql也支持多种储存引擎，每种存储引擎都有自己的特点，针对不同的的表使用不同存储引擎

​                      应用层方案：相对于来说把所有压力都给到数据库，其实我们在应用层还有很多操作可以让数据库减轻压力，也是一种对于数据库的调优，比如缓存，限流，异步

​                      读写分离：通过主库写，从库读，不但解决数据库事务隔离级别中的读写锁的竞争冲突，还有一有效分摊了数据库压力，不过也会带来数据延迟问题

​                       分库分表：按照业务去拆分数据库为垂直分库，把单张表按照一定规则拆分到不同表中为水平分表，这样拆分操作可以有效减少单个数据库结点的访问压力，已经单个表数据的存储压力

​                       高可用方案：如果数据库意外宕机了，或者某个结点搞了，无法提供访问，就会导致吞吐量下降，甚至无法响应，所有选择好的高可用方案也是提高数据线性能的基础



**9、合理使用索引？索引失效**

如何合理使用索引：

1. 为合适的列添加索引（主键，唯一，组合）
2. 尽量建立联合索引，能节省空间成本
3. 尽量使用覆盖索引

索引失效：

1. 索引列有null值不走索引
2. 使用is not 或 is not null不走索引
3. 各种负向查询not，not in，not like，<>,!=,!>,!<不会使用索引
4. like的%放左边不走索引
5. 查询条件的属性类型做了隐式转换
6. 使用in或union代替or，or两侧有非索引列就不会走索引
7. 保持索引列感觉，索引列上有函数转换，运算就会失效
8. 联合索引要遵循最左匹配原则
9. 使用比较运算或between会使联合索引从使用比较运算的下个个索引处断开



**10、排查慢查询？信息项？**

explain命令进行sql慢查询

1. id：select的查询序列号，表示查询中执行select子句或操作表的顺序，id相同顺序从上到下，不同则值越大优先级越高
2. select_type：查询类型，simple，primary，subqurey，derived，union，union result
3. table：正在访问那个表
4. prititions：匹配的分区
5. type：访问的类型：效率从快到慢：null>sysetm>const>eq_ref>ref>ref_or_null>index_merge>range>index>ALL
6. possible_keys：显示可能应用在这张表的索引，一个或多个
7. key：实际用到的索引
8. key_len：表示索引中使用的字节数，可以通过该列计算出查询中使用索引的长度
9. ref：显示索引那一列被使用了，那些列或常量被用于查找索引上的值
10. rows：根据表统计信息及索引选用情况，大致估算出找到所需记录读取的行数，这个数越小越好
11. filtered：查询的表占表的百分比
12. Extra：包含不适合在其他列中显示但十分重要的额外信息



**11、事务特性隔离级别？**

Mysql事务隔离级别有哪几种？

分别会产生什么问题？

Mysql默认隔离级别是什么？Oracle呢？

mysql的默认隔离界别是repeatable read，oracle默认隔离级别是read commintted

事务的特性是ACID

原子性：要么全部成功，要么全部失败

一致性：执行前后数据库信息必须保证一致

隔离性：一个事务在提交之前，其他事务是不可见的

持久性：事务完成后，会永久的保存到数据库当中，即使系统崩溃，执行的结果也不会丢失

隔离级别及问题：

| 事务隔离级别                 | 脏读   | 不可重复读 | 幻读   |
| ---------------------- | ---- | ----- | ---- |
| 读未提交（read-uncommitted） | 是    | 是     | 是    |
| 不可重复读（read-committed）  | 否    | 是     | 是    |
| 可重复读（repeatable-read）  | 否    | 否     | 是    |
| 串行化（serializable）      | 否    | 否     | 否    |

脏读：一个事务可以读到另一个事务尚未提交的信息，不符合事务的隔离性

不可重复读：同一个事务中针对同一行记录两次读出来的结果不一样，原因是第二次读到了其他事务修改的数据

幻读：同一个事务针对同一范围的数据两次读出来的结果不一样，原因是第二次读到了其他事务新增的数据

更新丢失：当多个事务选择同一行操作，并且都是基于最初选定的值，由于事务的隔离性，就会发生更新覆盖问题



**12、行锁表锁，悲观锁乐观锁**

行锁：InnoDB默认采用行锁，加锁可以保证事务的一致性。缺点是开销大，加锁慢，会出现死锁的情况，优点是锁的颗粒小，发生锁冲突的概率自然也低，处理并发的能力很强。

表锁：InnoDB在未使用索引字段查询时自动升级为表锁，mysql会根据自身计划考虑是否使用索引，如果mysql认为全表扫描效率更高，它就不会使用索引，这种情况下InnoDB将会使用表锁，而不是行锁，第一种情况就是全表更新，事务需要更新大量数据，而表又大，若使用行锁效率肯定降低，还有可能导致其他事务长时间等待和锁冲突，第二种情况就是多表查询，事务涉及到多个表，比较复杂的关联查询，很有可能会引起死锁，造成大量事务回滚，这种情况使用表锁，能一次性锁定事务涉及的表，从而避免死锁，减少数据库因事务回滚带来的开销。缺点，锁颗粒大，发生锁冲突概率搞，并发处理能力低。优点，开销小，加锁快，无死锁

悲观锁：悲观的认为本次事务一定会有别的事务干扰，操作之前必须加锁，在实现的适合要注意由于mysql锁是建立在索引上的，所以查询条件必须用主键索引，否则会造成全表扫描

乐观锁：乐观地认为本次事务操作数据不会有别的事物干扰，操作之前不进行加锁，只会预留一个版本号，真正修改数据的时候在进行比对



**13、vachar和char的区别？**

区别一： 变长和定长

vachar表示边长，即长度可变。char表示定长，即长度不可变。

区别二：存储容量不同

vachar最多存放65532个字符，最大有效长度由最大行大小和字符集确定。整体最大长度为65332字节

char最多能存放255个字符，和编码无关



**14、什么是内连接(inner join)、外连接（left join）？**

内连接可以理解为两张表的交集，

外连接分为左外连接和右外连接，左外连接相当于查询左边那张表所有的数据和交集部分的数据

​                                                      右外连接相当于查询右边那张表所有的数据和交集不发的数据

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCEdb035b68e83813ec759880250b5393ef/4755)





**16、Mybatis底层的原理？一级缓存和二级缓存是什么？**

在了解底层之前，可以先看看Mybatis执行流程：

（1）读取MyBatis的配置文件。mybatis-config.xml为MyBatis的全局配置文件，用于配置数据库连接信息。

（2）加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。

（3）构造会话工厂。通过MyBatis的环境配置信息构建会话工厂SqlSessionFactory。

（4）创建会话对象。由会话工厂创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。

**（5）Executor执行器。MyBatis底层定义了一个Executor接口来操作数据库，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。**

（6）MappedStatement对象。在Executor接口的执行方法中有一个MappedStatement类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。

（7）输入参数映射。输入参数类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程。

（8）输出结果映射。输出结果类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于JDBC对结果集的解析过程。

在执行流程里面最重要的就是两个对象就是configuration和transaction

configuration是mybatis的配置对象，是用来储存xml配置文件中解析到的所有数据，由三个非常要中的属性

environment：id确定连接的数据库，dataSource则是数据源

mapperRegistry：构建了所有Dao接口的Class对象，用来生成代理对象，在这里就可以知道底层就是动态代理

mappedStatements：储存方法名和sql语句

缓存：

一级缓存是mybatis自带的HashMap本地缓存，缓存的是sql语句。作用范围为session域中，当刷新或者关闭时session中所有缓存就会情况

二级缓存是全局缓存，缓存的是结果对象。作用域超出session范围之外，可以被所有sqlSession共享



**17、mybatis #{}和${}的区别？**

\#{}能防止sql注入，${}无法防止sql注入

\#{}表示的是一个占位符符号，而${}是将传入的数据直接显示生成到sql里面的

在JDBC能使用占位符的地方用#{}，在不支持占位符的地方就只能用${}，典型情况就是动态参数



**18、存储过程存储函数触发器，创建语法**

储存过程和储存函数都是一组sql语句的集合，这些语句集合被当作一个整体存入数据库中

存储过程语法：create procedure 储存过程名（参数列表） sql语句

存储函数语法：create function 函数名（）  return返回类型     sql语句

触发器：触发器是与表有关的数据库对象，在满足定义条件的时候触发，并执行触发器中定义的语句集合。触发器这种特性可以协助应用在数据库端确保数据的完整性

语法：create trigger 触发器名 before/after 触发事件 on 表名 for each row    begin 执行语句 end



**19、union和unionAll有什么区别？**

在将两个select语句结果最为一个整体展现出来，union会自动压缩多个结果集合中的重复结果，而union All 则会将所有的结果全部展示出来，不管是不是重复



**20、创建表、删除表、更新表字段语句？**

创建：create table 表名（里面设置字段名和字段条件）

删除：drop table 表名

更新： 1：增加表字段：Alter table 表名 add column 字段名 类型

​            2：删除表字段：Alter table 表名 drop column 字段名



**21、mysql左外连接语句的写法？**

select 查询字段 from 表名1  left join 表名2 on 查询条件



**22、听过InnoDB的Mvcc技术吗？说下是什么？**

mvcc是多版本并发控制器，目的是为了提交数据库在高并发场景下的性能

是Repeatable_read事务隔离级别的底层，保证AB客户端所示的数据相互隔离，互相更新不可见

Mvcc最大的优势，读不加锁，读写不冲突，在读多写少的情况下极大增加了系统的并发性

Mvcc的实现通过两个最重要的字段进行连接，DB_TRX_ID 和 DB_ROLL_PT,在多个事务进行并行操作某行数据的时候，不同事务对该行数据的update会产生多个版本，数据库通过ID来标记版本，然后用PT回滚指针将这些版本以先后顺序连成一条Undo log链

特点：每行数据都存在一个版本，每次数据更新时都会更新该版本

​           修改时copy出当前版本随意修改，各个事件无干扰

​           保存时比较版本号，如果成功则覆盖原记录，如果失败则放弃copy（rollback）



**23、Java实现动态代理有哪些方式？区别是什么？**

JDK动态代理和CGLIB动态代理

区别：

1：JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用invokeHandler来处理。CGLIB动态代理是利用字节码处理框架ASM，将代理对象类的Class文件加载进来，通过修改其字节码生成子类来处理。所有JDK创建代理对象效率高，但执行效率低。CGLIB创建效率低，但执行效率高。

2：JDK动态代理机制是委托机制，动态实现接口类，在动态生成的实现类里面委托Handler取调用原始实现类方法。CGLIB则使用的继承机制，被代理类和代理机制是继承关系，所以代理类是可以赋值给被代理类的，如果被代理类有接口，也可以赋值给接口。

**五：多线程**

**1、创建线程的方式有哪些？相比继承Thread类，实现Runable接口的好处是什么？**

创建方式

1. 继承Thread类
2. 实现Runable接口
3. 实现带返回值的Callable接口
4. 使用线程池创建线程

对比继承Thread类，实现Runable接口的好处

1. java是单继承有局限性。但是可以多实现，实现Runable接口之后还可以实现别的接口，代码健壮性更高
2. Runable接口可以说是多线程的底层，主要就是用来封装任务，Thread类也是通过他来实现的
3. 使用Runable接口可以很方便对共享资源进行传入



**2、线程的状态有哪些？**

1：新建（new）新建一个线程，但是还没有调用start方法

2：可运行（ranable）调用了start方法，但是还没有获得CPU的执行权，处于等待获取执行权的状态

3：运行（running）已经获得CUP的执行权，处于正常执行状态

4：阻塞（blocked）这种状态是指处于运行状态时因为某种原因放弃了使用CPU的执行权，暂时暂停了运行需要后续某些操作才可以继续进入运行状态，一般阻塞分为三种情况：

​               1）等待阻塞：运行的线程执行wait方法，JVM会把该线程放入等待队列中，当别的线程执行了notify或者notifyAll后可以对其进行唤醒进入锁池，让该线程处于抢锁状态，从而有机会从新进入可运行状态

​               2）同步阻塞：运行的线程在获取对象的同步锁时，若该线程被别的线程占用，则JVM会把该线程放入锁池中。

​               3）其他阻塞：运行的线程执行了sleep方法或join方法，或者发出I/O请求，JVM会把该线程设置为阻塞状态，当Sleep超时，join等待线程终结，IO处理完毕，线程重新进入可执行状态



**3、run()和start()方法有哪些区别？**

run只是一个封装方法的普通任务，调用run不会开启线程，start会开启线程，底层会调用run方法



**4、实现线程间通讯的方法有哪些？**

1：使用volatile关键字：实现线程间的相互通讯是使用共享内存的思想，大致意思就是多个线程监听同一个变量，这个变量发生变化的时候，线程能够感知并执行相应的业务，最简单的实现方式

2：使用Object类中的wait方法和notify方法，必须配合synchronized使用，wait会释放锁，notify不会释放锁

3：使用JUT工具类中的CountDownlatch，基于AQS框架，当相遇维护了一个线程间共享变量State

4：管道输入/输入流，用于线程间的数据传输，传输的媒介作为管道



**5、wait、notify、notifyAll分别的作用是什么？可以用在同步代码块之外吗？为什么？**

作用：

wait：让运行的线程进行等待

notify：在等待线程中唤醒其中一个线程，具有随机性

notifyAll：在等待线程中唤醒全部线程

不可以在同步代码块之外，为什么？：

1：在运行层面来说，如果写在别的位置会报非法监视异常，这里的监视器是锁对象

2：从原理层面来说，这三个方法是用于线程间通讯的，而控制线程通讯的主体对象是锁对象，使用这三个方法控制线程的时候必须先通过Synchoronized获取并指定锁对象

​      锁对象维护着一个等待队列List，通过锁对象调用wait方法则会让线程进入这个等待队列List，调用notifyAll方法则会从队列List中取出这个线程执行执行



**6、Sleep和Wait的区别？**

1：调用对象不同，sleep，jonin，yield，interrupted等都是属于Thread类的静态方法

​                               wait，notify，notifyAll扽都是object方法，任何对象都可以作为锁对象进行调用

2：是否释放锁：sleep不会释放锁，只是让出了CPU的执行权，但wait会释放锁，而且会加入到等待队列中

3：sleep可以在任何地方使用，wait只能在Synchronized同步方法或者同步块中使用

4：重新运行机制：sleep过了指定的睡眠时间就会从阻塞状态回到可运行状态，wait方法需要手动调用notify或notifyAll方法进行手动唤醒，进入锁池等待



**7、什么是线程安全问题？什么情况下会产生？如何解决？**

什么是线程安全：多线程操作共享资源时，导致共享资源出现错乱，线程安全问题都是由全局变量及静态变量引起的

什么情况下会产生：多个线程访问同一资源时，且对多个线程同时执行写操作，就会产生线程安全问题，例如电影院要通过三个窗口卖出一共100张票

如何解决：

线程同步：对一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程这时是处于等待状态。在此java中提供了同步机制（Synchronized）来解决，有三种方式完成同步操作，达成线程同步机制：

​                1）同步代码块，Synchronized关键字可以用于方法中的某个区域，表示只对这个区块的资源实现互斥访问

​                2）同步方法，使用Synchronized修饰的方法叫同步方法，保证一个线程在执行该方法的时候，其他线程只能在方法外等待

​                3）锁机制，Lock锁提供了比Sychronized代码块和Sychronized方法更广泛的锁定操作，这两个有的功能Lock都有。Lock锁也叫同步锁。

当然在解决线程安全问题的时候也要注意会不会死锁



**8、什么是死锁？如何防止产生死锁？**

死锁：在多线程程序中，使用了多吧锁，造成线程之间的相互等待，程序不往下走了，就是死锁

防止死锁：

1：加锁顺序，线程按照一定的顺序加锁

2：加锁时限，线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁

3：死锁检测：当一个线程获得了锁，会在线程和锁相关的数据结构中（如map）记录下来，除此之外每当有线程请求锁，也需要记录在这个数据结构中，当一个线程请求失败时，这个线程可以遍历锁的关系图是否有死锁发生，如果发生了可以给出相对于的提供方案，如释放所有的锁，或给这些线程设置优先级，让一个或几个线程回退



**9、Synchronized关键字的底层原理是什么?**

首先要直到java对象分为对象头，对象实例数据等，其中对象头的mard word部分记录对象的锁信息。

底层原理是通过monitor对象来完成的，monitor会内置在每一个对象中，任何一个对象都又一个monitor与之关联，Sychronized在JVM里面实现就是基于进入和推出monitor，底层是通过对MonitorEnter和monitorExit指令来实现。可以把monitor理解成一个同步工具



**10、Synchronized可以用在哪些地方？分别的锁对象是什么？**

Sychronized是java中的一个关键字，他的修饰对象分以下几种

1：修饰一个代码块，被修饰的方法称为同步语句块u，其作用范围是整个方法，作用的对象是调用这个方法的对象，锁对象是括号中的对象

2：修饰一个方法，被修饰的方法称为同步方法，其作用范围是整个方法，作用对象是调用这个方法的的所有对象，锁对象是为当前对象this

3：修饰一个静态方法，其作用范围是整个静态方法，作用的对象是这个类的所有对象，锁对象为Class字节码文件

4：修饰一个类，其作用范围是Sychronized后面括号括起来的部分，作用对象是这个类的所有对象



**11、JUC下Lock锁和Synchronized的异同？**

1：Lock是JUC包下封装好的锁，是类的概念。Sychronized是一个虚拟机层面的关键字

2：Lock显示的加锁和隐锁，且解锁要在finally代码块中，否则可能会死锁。而Sychronized为隐式的上锁和解锁

3：Lock锁提供了尝试获取锁和设置获取锁的时间的机制，可返回去锁状态，当获取不到锁的时候也可以选择放弃锁。Sychronized无法判断返回取锁状态，取锁不成功直接阻塞，没有Lock灵活

4：Lock锁阻塞可以被打断，而Sychronized阻塞不可被打断

5：Lock可实现可重入，可公平锁，而Sychronized是可重入，非公平锁

6：Lock可以很灵活的根据线程角色类型去创建Condition监视器对象，调用await，signal，signalAll进行线程通讯调度。而Sychronized使用Object对象作为监视器对象，调用的是wait，notify，notifyAll去进行线程通讯调度。

7：Lock提供了更丰富的锁分类，如读锁，写锁，可以更颗粒化的关注线程安全



**12、Synchronized在JDK1.6做了什么优化？**

自适应的CAS自旋，锁消除，锁粗化，偏向锁，轻量级锁



**13、Synchronized是公平锁还是非公平锁？获取不到锁时会阻塞吗？**

非公平锁，会，因为Sychronized无法判断返回的取锁状态。



**14、同步代码块中执行完wait/notify/notifyAll后会立马释放锁吗？**

不会，必须要等待所在的同步代码块执行玩才会释放锁。



**15、Lock锁有哪些实现？分别的特点是什么？**

公平锁与非公平锁

特点：公平锁多了一步hasQueuPredecessors（）的判断，限制了当前线程如果是等待线程的头结点才回去获取锁保证了公平性，而非公平锁则没有这个限制，可以直接去插队尝试获取锁



**16、JUC下Lock的监视器对象是哪个类？与Synchronized的监视器有什么异同？**

Lock的监视器是Condition接口，Sychronized是monitor

异同：

前置条件：Condition调用Lock获取锁或是调用newCondition获取Condition对象，monitor是直接获取对象的锁

调用方法：Condition是 await，signal，signalAll。monitor是wait，notify，notifyAll

等待队列个数：Condition支持多个，monitor只支持一个

当前线程释放锁并进入等待状态不响应中断：Condition支持，monitor不支持



**17、什么是线程可重入？Synchronized具备吗？Lock呢？**

可重入：在一个线程某个方法获取锁后，进入该线程的其他方法不需要重新取锁。都具备



**18、什么是AQS？**

AQS是用于构建锁和同步容器的队列同步器，它是整个JUC体系的核心，如ReentrantLock，ReentrantReadWriteLock，CountDownLatch，Semaphore都是基于它实现的，它解决了同步容器设计的大量细节问题，他的核心构成部分为：一个先进先出的FIFO队列储存排队等待锁的线程，用一个Volatile修饰的Int类型的State同步状态来记录当前线程是否有锁，0表示没有线程获得锁，1表示有，上锁state就加1，释放锁就对应-1，有重入锁这个值就大于1，然后需要逐级去释放。



**19、什么是CAS？什么是CAS的ABA问题？如何解决？**

CAS其实就是乐观锁的一种实现方式，而悲观锁比较典型的就是java中的Synchronied

CAS全称Compare and swap——比较并替换 保证了数据的原子性，它是并发条件下修改数据的一种机制，包含了三个操作，1）需要修改数据的内存地址记录为（V） 

​                             2）记录这个数据当前的值记录为（A）

​                             3）需要修改时查看下地址V的值，如仍为A，则用B替换他，若地址V下的值不为A，表示在修改的过程中其他线程对数据进行了操作，则不更新变量的值，而是从步骤2开始执行，这一步也称为自选。                      CAS贯穿于整个AQS体系，是AQS实现的基础。

优点：CAS是乐观锁，不需要加锁就能进行原子操作

缺点：CAS机制只能用在对于某一个变量进行原子操作，无法用来保证多个变量或语句的原子性

​           如果在修改数据的过程中经常与其他线程修改冲突，将导致多次重试

​           有可能产生ABA问题

ABA问题：假设小明在提款机提取了50元，因为提款机的原因有两个线程同时把余额100改成50

线程1：获取当前值100，期望更新到50

线程2：获取当时值100，期望更新到50

线程1成功执行，线程2因为某种原因阻塞，这时某人给小明汇款了50

线程3：获取当前值50，期望更新到100

这时线程3执行成功，余额变成100，这时线程2从阻塞中恢复了，执行之后又将值改为了50

此时可以看到实际余额应为100，但实际上变成了50，这就是ABA问题

解决：在变量上加上版本号，每次变量更新的时候变量的版本号+1，即A-B-A就变成了1A-2B-3A



**20、你了解JUC下的哪些工具类，分别有什么作用？（CountdownLatch、Cyclicbarrier、Semaphore）**

1：CountDownLatch：通常用来控制某个线程等待，让某组线程执行完才能执行调用await的线程

具有计数器功能，构造方式初始化数量，通常调用await方式控制某个线程等待，其他线程执行完后会CountDown一次进行减1，直到CountDown为0才会执行阻塞线程

需要注意：CountDownLatch计数的次数一定要与构造器传入的数字一样，比如构造器传入的是3，则CountDown一定要执行3次，否则await的线程将一直阻塞

2：CyclicBrarier：类似CountDownLatch，区别是CountDown之后才会执行自己的任务。而CyclicBrarrier会在所有线程任务结束之后，才会执行后续任务。

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE65d3c9a2e6e7ad7aa5dcd0767611d9c5/5904)

3：Samephore：常用于控制某一贡献资源访问的访问线程的最大数。也是一种计数器，用来保护一个或多个共享资源的访问，如果线程要访问一个资源就必须先获取信号量，如果信号量内部计数器大于0，信号量-1，然后允许共享这个资源，如果信号量的计数器等于0，信号量就会把线程置入休眠状态直到计数器大于0，当信号量用完时，必须释放



**21、说下volatile关键字，有什么作用？原理是什么？**

volatile是java的关键字，是一个类型变量修饰符，被volatile修饰的变量有以下几个特性

1：可见性，保证了不同线程对这个变量进行操作的可见性，即一个线程修改了某个变量的值，这个新值对其他线程来说是立即可见的。

​              如何实现的：用volatile形容的变量，线程写入本地内存的同时会将数据立即刷新到主内存中。其他线程读取该变量的时，发现被volatile修饰，会将本地变量值置为无效，直接从主内存中读取

2：有序性，禁止进行指令重新排序。为了提高执行效率，在不影响最终执行结果的前提下，代码在编译成字节码的时候有可能进行指令重新排序，这个在单线程情况下是没有问题的，但是在多线程的情况下会出现问题，volatile则可以避免这个问题

3：不保证原子性，volatile只能保证单词读写的原子性，例如i++这种操作不能保证原子性，关于volatile原子性可以理解为把对volatile变量的单个读写，看成是使用同一个锁对这些单个读写操作做了同步



**22、说下ThreadLocal，有什么作用？有哪些主要方法，实现原理是什么？为什么会有内存泄漏问题？如何解决？**

作用：ThreadLocal是JDK包提供的，它提供本地线程变量，如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个副本，在实际多线程的操作中，操作的是自己本地内存中的变量，从而规避了线程安全问题

主要方法：get，set，remove

实现原理：每个线程都有属于一个自己的ThreadLocalMap，可以通过Thread获得，这个map储存着以ThreadLocal对象为Key，设置的值为value的键值对，调用get，set，remove方法都是操作这个map

内存泄漏：

ThreadLocalMap使用ThreadLocal的弱引用作为key，如果ThreadLocal没有外部强引用他，那么当系统GC的时候，这个ThreadLocal势必会被回收，这样依赖ThreadLocalMap就会出现key为null的Entry。就没有办法访问这个key为null的Entry的value。如果当前线程在迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：ThreadLocalREF —ThreadLocal—ThreadLocalMap—Entry—Value，永远无法回收，造成内存泄漏

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCEe836810e9206e2afbd75578852eb3773/6074)

解决方法：在使用完ThreadLocal后执行remove操作，避免出现内存溢出的情况。



**23、说下线程池的几大核心参数？分别有什么作用？有几种默认的线程池？他们的7个核心参数为什么要那么设置？**

核心参数：

1：corePoolSize，核心线程数大小，当线程数

2：MaximunPoolSize，最大线程数，当前线程数>=corePoolSize的时候，会把任务放入workQueue队列中

3：keepAliveTime，保存存活时间，当前线程数大于corePoolSize的空闲线程能保持的最大时间

4：unit，keepAliveTime的时间单位

5：workQueue，保存任务的阻塞队列

6：ThreadFactory，创建线程工厂

7：handle，当前最大线程数量后执行的拒绝策略

**默认线程池：**

**newSingleTreadExecutor：单线程的线程池，**它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来代替它，特点：能够确保依照任务在队列中顺序来串行执行。

​			创建细节：new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue()));

**newFixedThreadPool：固定大小的线程池**，每次提交一个任务就创建一个线程，直到线程达到线程池的最大数量，这时线程规模将不会变化。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池就会补充

​	                创建细节：new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());

**newCachedThreadPool：可缓存的线程池**，如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（设置空闲线程最大保持时间的时间数）的线程，当任务数增加时，此线程又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小

​                       创建细节：new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue());



**24、单例模式写法有哪几种？（懒汉和饿汉式）那么懒汉式中保证线程安全的写法是什么？为什么要用双重检查模式？**

写法：

1：懒汉式，顾名思义用到的时候才去创建，如需要线程安全可加上Sychronized关键字

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCEcd0af9b58f5724052e206a8487efb336/6292)

2：饿汉式，实例在初始化的时候就创建按好了，没有线程安全问题，但浪费了内存空间

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE0b8fbdf7dc4bfdb0cb13a612a5235584/6294)

3：双检锁

双检锁又叫双重校验锁，综合了懒汉式和饿汉式两者的优缺点整合而成。特点在Sychronized关键字内外部都加了if判断，这样既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间

所谓双重检查机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后先检查实例是否存在，如果不存在才进入下面的同步块，这时第一次检查。进入同步块后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间

这种方式既可以实现线程安全的创建实例，又不会对性能造成太大的影响，它只在第一次创建实例的时候同步，以后就不需要同步了，从而加快允许速度

**注意volatile修饰变量的使用。**volatile关键字可能会屏蔽虚拟机中一些必要的代码优化，所以运行效率并不高，因此一般建议没有特别的需要，不要使用。也就是说虽然双检索机制用来实现线程安全的单例，但并不建议大量采用，根据情况而定

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCEae76a95a3c3a1d8f9df31b8d35a0efe4/6316)

4：静态内部类

5：枚举

**六：Redis & 多级缓存**

**1、Redis是一个什么样的数据库？读写速度怎么样？**

Redis本质上是一个Key—value类型的数据库，整个数据库加载都在内存当中操作，定期通过异步操作把数据库中的数据flush到硬盘中保存

因为是纯内存操作，redis的性能十分出色，每秒可以处理超过10W次读写操作，是已知性能最快的Key—value类型的数据库。



**2、Redis有哪些数据类型，分别的特点？在你们项目中常见的应用场景有哪些？请列举**

1：String类型，最常用的一种数据类型，普通的key—value储存都归于此类，其中value既可以是数字也可以是字符串，使用场景：常规的key value缓存应用，常规计数：粉丝数

2：Hash，是一个键值对集合，是一个String类型的field和value的映射表，Hash特别适合储存对象，并且可以像数据库中的update一个属性一样，只修改某一项属性值

3：Set，是一个无序的天然去重集合，即key—set，此外还提供了交集，并集等一系列直接操作集合的方法，对于共同好友，共同关注什么功能的实现特别方便

4：List，有序可重复的集合，遵循FIFO原则，底层是依赖双向链表实现的，因此支持正向，反向双重查找。通过List我们可以很方便的获得类型最新回复这类功能的实现

5：SortedSet，类似与java中的TreeSet，是Set的可排序版本，此外还支持优先级，维护了一个score的参数来实现，适用于排行榜和带权重的消息队列



**3、Redis的持久化机制是什么样的？**

​	**1）、什么是RDB？RDB的持久化机制（Save、bgSave）?**

**在指定的时间间隔将内存中的数据快照写入磁盘**，它恢复是将快照文件直接读到内存

机制：

**Save**：save命令会导致主进程执行RDB，这个过程中其他所有命令都会阻塞

**bgSave**：bgSave命令后会开启独立进程完成RDB，主进程可以继续处理用户请求，不受影响



​	**2）、触发RDB的时间点是什么？**

在四种情况下会运行：**执行save命令。执行bgsave命令，redis停机时，触发RDB条件时**

触发RDB条件则是自己在redis.conf文件里面进行配置



​	**3）、RDB的优缺点分别有哪些？**

**优势**：适合大规模的数据恢复，对数据完整性和一致性要求不高

**缺点**：执行时间较长，且在一定间隔时间做一次备份，如果这时redis意外down掉的话，就会丢失最后一次快照后的所有修改，fork子进程，压缩，写出RDB文件都比较耗时



​	**4）、什么是AOF？分为几个阶段？(命令写入缓冲区、同步至日志文件、文件重写)**

**以日志的形式来记录每个操作，将redis所有操作但不包括读操作记录下来**

**阶段：命令写入缓冲区，同步至日志文件，文件重写**



​	**5）、AOF命令同步至日志文件分为哪几种？**

**Always：同步刷盘**

**everyesc：异步操作，每秒刷盘一次**

**no：系统控制时间**



​	**6）、AOF文件重写时间点？重写做了什么？**

**当AOF文件过大时，redis就会对该文件进行自动重写**

**自动重写：**重写时间点就是当AOF文件大小**超过指定的阈值，就会重写**，这个可以在redis.conf里面去配置

**手动重写：**执行bgrewriteaof命令

做了什么：AOF会记录对同一个key的**多次操作，只会保留最后一次操作**



​	**7）、AOF的优缺点分别有哪些？**

**优点**：Always，同步持久化，每次操作都会立即记录到磁盘，性能差但是数据完整性高

​          everyesc，异步操作，每秒记录，性能适中，但一秒内宕机，这一秒的数据会丢失

​          no，性能最好，但可靠性较差，可能丢失大量数据

**相对于RDB的缺点**：AOF的文件要远大于RDB文件，恢复速度也慢于RDB

​                                 AOF运行效率要慢于RDB，每秒同步策略比较好，no效率和RDB相同



​	**8）、AOF和RDB同时开启会优先使用哪种进行数据恢复？**

**如果是数据不那么敏感**，可以从别的地方重写生成不回，可以关闭持久化

**如果是数据比较重要**，不想再从别的地方获取，且可以承受数分钟的数据丢失，比如缓存等，那么可以只是用RDB

**如果是做内存数据库**，**建议是RDB和AOF都打开，或定期执行bgsave命令**，RDB方式更适合做数据的备份，而AOF则是保证数据的不丢失，对了**4.0以后的redis对于持久化机制有优化，那就是RDB_AOF混合模式**



​	**9）、RDB-AOF混合模式是什么？优点有哪些？**

简单来说就是新的**AOF文件前半段是RDB格式的全量数据，后半段是AOF格式的增量数据**

**优点：**混合模式结合了RDB和AOF的优点，由于绝大部分都是RDB格式，加载速度快，同时结合AOF，增量数据是以AOF方式保存，数据更少的丢失

**缺点**：兼容性差，一旦开启了混合模式，在4.0之前的版本都不是识别该文件，同时由于前部分是RDB格式，阅读性差



**4、Redis主从结构能解决什么问题？**

提高并发，读写分离，主从同步保证数据的一致性



**5、Redis主从同步具体流程是什么？**

​	**1）、建立连接**

slave向master发送建立连接请求

master判断是否是第一次建立连接，如果是第一次会发送master数据库版本信息，然后master执行bgsave生成RDB文件发送给slave。这也就是全量同步，如果不是第一连接，则会做增量同步



​	**2）、数据同步（全量同步、增量同步）【runid运行ID、offset偏移量、复制积压缓冲区】**

​		1、**全量同步具体场景有哪些？流程？如何避免全量同步次数（全量同步非常耗时）**

**场景：**在第一次master ，slave连接时，或是slave阶段断开太久，repl_boklog中的offset已经被覆盖

**流程：**master判断是否是第一次建立连接，如果是第一次会发送master数据库版本信息，然后master执行bgsave生成RDB文件发送给slave，这时master也会有一个repl_baklog文件来记录RDB期间所有的命令发送给slave

**避免**：提高repl_baklog文件大小，发现slave宕机时尽快实现故障恢复



​		2、**增量同步具体场景有哪些？流程？**

**场景**：slave节点断开又恢复了，并且在repl_baklog中找到了offset

**流程**：slave会执行replicaof命令发送replid，offset给master，master判断replid是否一致，不是第一次，回复continue，去repl_baklog中获取offset数据，然后发送offset后的命令给slave

master知道slave与直接数据差异的原理：**repl_baklog**

这个文件是第一次建立主从的时候 master发送给slave的，这个文件是一个环形数组，也就是角标达到数组末尾后，会再次从0开始读写，这样头部数据就会覆盖，repl_baklog会记录redis处理过的日志和offset，包括master的offset和slave的offset。只要master的offset没有覆盖slave的offset就会继续增量同步，如果已经覆盖，那就会全量同步



​	**3）、命令传播**

**6、如何优化主从同步效率？**

​	**1）、从尽量避免全量同步的方面入手（安全重启使runid不发生变化、调大复制积压缓冲区）**

安全重启，让runid不发生变化

提高repl_baklog文件大小



​	**2）、避免slave从结点太多造成复制风暴（使用树状拓补结构）**

现在一个master上的slave节点，如果实在太多slave，则可以采用主—从—从链式结构

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE6778b4f6eed49ced328136d34fb33792/6898)



**7、Redis的故障恢复依靠什么机制？哨兵机制的主要工作范围、工作流程和作用？**

哨兵机制

工作范围：监控redis集群

作用：监控 故障转移 通知

工作流程：

sentinel基于心跳检测服务状态，每**一秒**向集群中每个实例发送ping命令

​                  主观下线：**某个sentinel节点发现某实例在规定时间内未响应**

​                  客观下线：**超过指定数量（quroum）的sentinel都认为该实例主观下线了**，则该实例为客观下线。quroum值最好为实例数量的一半

**1：**一旦发现master故障，sentinel则会在slave选择一个作为新的master，依据

​                    1：**判断slave节点与master节点断开的时间长短**，如果超过指定值（down after milliseconds * 10）则会排除该slave节点

​                    2：**判断该slave节点的slave_ping值**，越小优先级越高，如果时0则用不参与选举

​                    3：如果slave_ping值一样，则**判断slave的offset值**，越大说明数据越新，优先级越高

​                    4：最后判断**slave节点的运行ID大小**，越小优先级越高

**2：**选举成功后sentinel会给该slave节点发送slaveof no one命令让该节点变为master

**3：**sentinel会给其他所有slave节点发送slaveof （主节点的IP和端口） 让这个slave成为新master的从节点，开始从新的matser上同步数据

**4：**最后sentinel将故障节点标为slave，改故障节点恢复后会自动成为master的slave的节点



**8、什么是缓存雪崩？缓存击穿？缓存穿透？分别如何解决？什么是缓存预热？**

**缓存雪崩：**

**某一个时刻大规模的key失效，**导致大量的请求到了数据库上面，导致数据库压力巨大，在高并发的情况下，可能瞬间就会导致数据库宕机。这时如果马上重启数据库，又会有新的流量把数据库打死

​                  **解决：事前：**

​                                   1**）均匀设置不同的过期时间，**避免相同的过期时间导致缓存雪崩，保证数据不会在同一时间大面积失效

​                                   **2）分级缓存**，第一级缓存失效的基础上，访问二级缓存，每一级缓存失效时间不同

​                                   **3）热点数据永不过期**，不设置过期时间或者是当发现要过期了，通过一个后台异步线程进行再次缓存

​                                   **4）主从+哨兵模式**，避免redis全面崩溃

​                             **事中：**

​                                   **1）互斥锁**，缓存失效后，通过互斥锁或队列来控制读数据和写缓存的数据进程，比如某个key只允许一个线程读数据和写缓存，其他线程等待。虽然防止了缓存雪崩，但是会让系统吞吐量下降

​                                   **2）熔断机制，限流降级**，当流量达到一定的阈值，直接返回“系统拥挤”等字样，防止过多的请求直接打到数据库上，至少能保证一部分用户使用时正常的，其他用户多刷新几次也可以访问

​                              **事后：开启redis持久化机制**，尽快恢复缓存数据，一旦重启就能从磁盘上自动加载数据，恢复内存中的数据

**缓存击穿：**

击穿与雪崩有点类似，雪崩时大规模的key失效，击穿则是某个热点key失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压剧增

​                  **解决方法：**

**1）互斥锁，**缓存失效后，通过互斥锁或队列来控制读数据和写缓存的数据进程，比如某个key只允许一个线程读数据和写缓存，其他线程等待。虽然防止了缓存雪崩，但是会让系统吞吐量下降

**2）热点数据永不过期，**不设置过期时间或者是当发现要过期了，通过一个后台异步线程进行再次缓存

**缓存穿透：**

指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，每请求一次该数据都要去数据库中查询一次，如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落到数据库上，造成数据库压力过大，导致数据库承受不住压力而宕机

​                  解决方法：1）将无效的key存放进redis中，当出现redis，数据库都查不到数据时，我们把这个key存入redis中，设置value=null，并设置过期时间极短，后面在出现这个key的查询直接返回null

​                                    2）使用布隆过滤器，如果布隆过滤器判断某个key不存在过滤器中，那么就一定不存在，如果判断存在，那么很大可能是存在（有一定误差），在缓存之间加一个布隆，将数据库中的所有key都存在布隆中，查询redis之前先去布隆查询，key是否存在，如果不存在直接返回，不让其访问数据库，避免对底层储存系统的查询压力

**缓存预热：**

系统上线后，提前对相关的缓存数据加载到缓存系统当中，避免用户在请求时先查询数据库，在缓存的问题，让用户直接查询实现被预热的缓存数据



**9、Redis是单线程的，为什么读写效率还那么高？**

单个线程处理请求，避免了多个线程之间线路切换和锁资源争用的开销

6.0之后引入多线程IO，只用来处理网络数据的读写和嫌疑的解析，执行命令依旧是单线程



**10、Redis的线程模型是什么样的？（典型的NIO，非阻塞式IO）**

NIO，非阻塞式IO



11、Redis过期数据的删除策略是什么？有哪些？

**最佳的删除策略：惰性删除和定期删除一起用**

惰性删除：不回去主动删除数据，而是在访问数据的时候，在检查键是否已经过期，如果过期执行删除并返回null，没过期则正常返回

定期删除：redis周期性的随机测试一批设置了过期时间的key进行处理，测试到过期的key直接删除

**常见的有三种**：

​                     1）**定时删除**，设置某个key过期的同时，创建一个定时器，让改定时器在改过期时间到来时，立即执行对其进行删除的操作

​                                       优点：对内存友好，能够保证内存的key一旦过期就能立即从内存中删除

​                                       缺点：对CPU不友好，在过期key较多时，删除过期键会占用一部分cpu时间，对服务器会造成响应时间和吞吐量的影响

​                     2）**惰性删除**，改key过期后不去管他，当需要该key的时候，在检查是否过期，如果过期就删除，反之则返回该key

​                                       优点：对CPU友好，只有在使用该key的时候才会对其进行检查，对于很多用不到的key不用浪费时间对其进行检查

​                                       缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，该键就会一直在内存中，如果有很多这种用不到的的键，这些键便永远不会删除，内存永远不会释放，从而造成内存泄漏

​                     3）**定期删除**，每隔一段时间，对进行检查，删除里面过期的key

​                                       优点：可以通过限制操作执行的时长和频率减少删除操作对CPU的影响，能够有效释放内存

​                                       缺点：难以确定定期删除时间，如果执行的频繁就会和定时删除一样，如果不平凡就会和惰性删除一样。最重要的是在获取某个键时，如果某个键的过期时间已经到了，但是还没执行删除任务，那么就会返回这个键的值，这是业务不能容忍的错误



**12、Redis的数据淘汰策略是什么？有哪些？**

redis在内存超过最大允许的内存之后，redis会触发内存淘汰策略，删除一些不常用的，保证redis的正常运行

4.0之前的淘汰策略：（lru算法：最近使用 least recently used）

​           volatile-lru：利用LRU算法移除设置过期时间的key

​           allkeys-lru：当内存不足以写入新数据时，在键空间中移除最少使用的key（最常用的）

​           volatile-ttl：从已设置过期时间的数据集中挑选将要过期的key

​           volatile-random：从已设置过期时间的数据集中任意选择数据淘汰

​           allkeys-random：从数据集中任意选择数据淘汰

​           no-eviction：禁止淘汰数据，当内存不足时会直接报错

6.0之后新增的：

​           volatile-lfu：从已设置过期时间的数据集中挑选最不常用的数据淘汰

​           allkeys-lfu：当内存不足时，在键空间移除最不常用的key

内存淘汰策略可以通过配置文件来修改，Redis.conf对应的配置项是maxmemory-policy 修改对应的值就行，默认是noeviction。



**13、Redis的慢查询如何排查？**

redis中有慢查询日志，直接修改配置文件或者是输入命令设置慢查询日志

**slowlog-log-slowr-then预设阈值，单位微秒**

**slowlog-max-len慢查询日志最大储存条数**

**slowlog-get 获取慢查询日志**



**14、如何正确使用Redis的分布式事务锁？（Zookeeper也可以实现分布式锁）**

**1：加锁，使用setnx加锁**，key是锁的唯一标识，当执行setnx返回1，说明key原本不存在，该线程得到了锁。当返回0，说明key已存在，线程抢锁失败

**2：解锁，使用del解锁**，线程得到锁之后执行完任务，需要释放锁让其他线程可以进入

**3：锁超时，**setnx的key必须设置一个超时时间，以防如果得到锁的线程在执行时挂到，来不及释放，这块资源就会永久锁住，setnx不支持设置超时参数，所有需要额外指令 **expire key （时间）**

**2.6.12之后的版本set指令增加了可选参数**， seconed设置过期的秒数，milliseconed设置过期的微秒**，NX键不存在时对键进行操作，XX键存在时对键进行操作**

**问题：**

**锁误删，**当A获取到锁后，并设置过期时间为30秒，A执行的时间超过了30秒，锁过期自动释放，此时B获得了锁，随后A执行完成使用del命令释放锁，这时B还没完成任务，但是锁已经被A释放了

​           解决：在del释放锁之前加一个判断，验证当前是否为自己的锁

**超时导致并发**，当A获取到锁后并设置过期时间为30秒，A执行的时间超过了30秒，锁到期自动释放，此时线程B获取到锁了，和A并发执行

​            解决：延长过期时间，确保代码逻辑在锁释放之前执行完成。增加守护线程，为要过期但未释放的锁增加有效时间



**15、Redis的双写一致性如何保证？**

四种方案：

1：先更新数据库，后更新缓存

2：先更新缓存，后更新数据库

**3：先删除缓存，后更新数据库**

**4：先更新数据和，后删除缓存**

第一第二种是没有人使用的，第一种方案的问题是并发更新数据库，会将脏数据刷到缓存

第二种问题是，如果先缓存更新成功，数据库更新失败则造成数据不一致

主要使用第三种或者第四种



**16、项目搭建多级缓存的好处是什么？实现多级缓存的流程是什么？（加分项）**

充分利用请求处理的每个缓解，分别添加缓存，减轻服务器压力

- 浏览器访问静态资源时，优先读取浏览器本地缓存
- 访问非静态资源（ajax查询数据）时，访问服务端
- 请求到达Nginx后，优先读取Nginx本地缓存
- 如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）
- 如果Redis查询未命中，则查询Tomcat
- 请求进入Tomcat后，优先查询JVM进程缓存
- 如果JVM进程缓存未命中，则查询数据库

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE15617e3e139c671513653e3d8e7189b6/7620)



**17、Redis的hash槽一共有多少个？数据是如何进行入槽的？如果实现动态扩容？**

16384个插槽

如何入槽：利用CRC16算法得出一个hash值，对16384取余，得到的结果就是slot值，如果key时num就对num取余，如果key是{CRC16}num 就对CRC16取余

**七、Rabbitmq**

**1、Rabbitmq消息模式有哪些？你们用的哪种？（5种）**

1：simple-queue 简单消息队列模式

2：work-queue 工作消息队列模式

3：fanount 发布订阅模式

4：direct 路由模式

5：topic 主题模式

​       模式：消息生产者（routingKey）--topic交换器--与交换机绑定的队列（boudingKey）--消息消费者

​       流程：消息生产者携带routingKey发送到topic交换机，topic交换机根据更具boudingKey将消息转发到与自己绑定规则的队列中，消息消费者对队列中的消息进行消费

​       通配符说明：*匹配一个单词，#匹配多个或0个单词



**2、Rabbitmq如何保证mq消息可靠性？（3大方面）**

1：保证消息传递不丢，开启生产者消息确认机制

​     1）开启ConfirmCallBack回调，消息传递到交换机的回调（成功，失败，异常）

​     2）开启ReturnCallBack回调，消息从交换机未路由到队列的回调

2：保证消息达到MQ后不丢（MQ宕机了也不影响），消息持久化（默认就是持久化）

​     1）交换机的持久化    2）队列的持久化     3）消息的持久化

3：保证消费者不丢（必须至少消费一次），开启消费者消息确认机制

​     1）none 没有确认机制，如果出现异常会直接丢弃

​     2）manual：手动确认， 可以自己灵活控制消息的确认和拒收，开启这个机制之后一定要记得手动回执，否则会造成大量堆积问题

​     3）aotu 自动确认，优点：出现异常返回nack，正常执行返回ack，无需编写业务代码，无侵入（AOP）

​                                     缺点：当消费消息出现异常返回nack时会一直反复投递，

​                                              解决：开启消费者重试机制，消费消息失败时，消费者会自己发起重试，重试间隔和最大重试次数可灵活配置，当超过最大重试次数时，消费者对于消息有以下几种策略

​                                               1：直接丢弃，该消息从MQ删除

​                                               2：放回消息队列，然后投递给消费者，消费者进行重试，如此循环

​                                               3：投递至指定的交换机，绑定队列后进行精准消费



**3、Rabbitmq如何实现延时消息？（2种）**

1：利于死信交换机实施延迟传递

​      原理：设置消息超时未被消费会被投递至死信交换机

​      设置超时：1：针对消息设置延迟时间   2：针对队列设置延迟时间

2：利用延迟交换机插件实现延迟传递

​      原理：交换机延时路由，达到指定的时间会被路由至队列



**4、什么是死信队列？什么样的消息会进入死信队列？**

处理垃圾信息的队列，有以下三种消息会进入死信队列

1：被拒绝或nack的消息

2：队列放不下的消息

3：超时过期的消息



**5、Rabbitmq如何解决消息堆积问题？（3种思路）**

1：针对同一队列增加多个消费者进行消费

2：针对同一消费者开启多个线程进行消费

3：加大队列的储存容量，惰性队列

​       原理：直接将消息写入到磁盘

​       优点：储存容量大，减少从内存刷消息数据到磁盘的次数，性能稳定

​       缺点：性能取决于IO



**6、如何保证消息的幂等性？（从业务层面进行判断）**

**幂等性的实质：**对于一个资源，不管时一次请求还是多次请求，对资源本身造成的影响应该是相同的，不能因为重复的请求而对该资源造成影响

**首先要知道什么情况下MQ会非幂等**

1：consumer接收到消息处理完成后，给broker返回ack途中断网，broker未收到确认消息，根据MQ的重试机制，则会再次发送该消息给consumer，造成消息的重复消费

2：在开启生产者confirm模式下，生产者已经把消息发送给broker，但在broker传回ack确认时断网，生产者也会重新发送消息，造成broker收到了重复的消息，最后这两条重复的消息都会发送给消费端，造成了消息的重复消费

**通过这两种场景，我们可以得知MQ的幂等性保障应该是在消费端，要保证MQ的幂等性，就要保证消费者不会重复消费消息**

如果解决这个问题：

**设置全局唯一ID+redis**

生产者在发送消息时，**为每一条消息生成一个全局唯一messageid，消费者拿到消息后，使用setnx命令，将messageid作为key放入redis中**，setnx（messageid，1）若返回1说明之前没有被消费过，正常消费。若返回0表示这条消息已经被消费过，抛弃

**八、微服务**

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE7a382620e71c1ba91b53e7b02fdf11f7/8204)



​	**1、概念问题**

​		**1）、什么是微服务？解决微服务各种问题都用了哪些组件？**

分布式架构：对单体架构进行拆分，解耦，有利于服务器拓展

微服务本质上是经过各大公司校验的一个优秀的分布式架构

组件：dubbo，SpringCloud，SpringCloudAlibaba



​		**2）、什么是单体架构、什么是分布式架构、什么是微服务架构？**

单体架构：所有的业务，模块耦合在一个项目中，容易产生系统瘫痪

分布式架构：对单体架构进行拆分，解耦，有利于服务器拓展

微服务架构：本质上是经过各大公司校验的一个优秀的分布式架构



​		**3）、微服务有哪些特点？**

1：单一职责，对业务进行颗粒化细分，避免重复代码的编写

2：面向服务，暴露提供的restful风格接口

3：自治

4：服务隔离，服务之间互不影响，熔断，降级，防止级联雪崩

​	**2、远程调用**

​		**1）、什么是Feign，用来做什么的？Feign底层调用是怎么实现的？底层协议是什么？优势是什么？**

什么是feign：Feign是一个声明式的Http客户端

用来做什么的：帮我们优雅的实现Http请求的发送

底层调用：基于面向接口的动态代理方式生成实现类，将请求委托到动态代理实现类

底层协议：Contrect协议



​		**2）、服务间调用，其中一个服务宕机了，这个时候怎么做呢？**



​		**3）、Ribbon是什么？负载均衡策略有哪些？底层原理是什么？默认是哪种？**

Ribbon是什么：Ribbon是一个简化客户端远程调用的负载均衡器

负载均衡策略：

RoundRobinRule：简单的轮询服务来选择服务器，默认的规则

BastAvailableRule：忽略短路的服务器，选择并发低的服务器

RandomRule：随机选择一个服务器

RetryRule：重试机制的选择逻辑



​		**4）、Ribbon是如何实现轮询的？如果让你自己实现轮询，如何实现？**	

Ribbon会拦截我们的TestTemplate请求

RibbonLoadBalancerClient会从请求Url中获取服务器名称

DynamicServerListLoadBalancer根据服务器名称到注册中心拉取服务列表

注册中心返回列表，IRule根据内置负载均衡规则，从列表中选择一个，例如localhost：8080

RibbonLoadBalancerClient修改请求地址，用localhost：8080代替服务器名发起真实请求



​		**5）、Feign和Ribbon的关系是什么？**

Ribbon是一个基于Http和TCP客户端的负载均衡工具，

Feign是在Ribbon的基础上做了改进，是一个使用起来更加方便的Http客户端，采用接口方式，将需要调用的服务定长成抽象接口，不需要自己构建Http请求



​		**6）、你们项目中如何使用Feign的（Feign的最佳实践）**

最佳实现由两种，继承和抽取

继承：不推荐，定义一个API接口，利用定义方法，并基于Spring'MVC注解做声明，Feign客户端和Controller都集成该接口，不过缺点太明显，服务提供方和消费方紧密耦合，而且参数列表中的注解映射并不会继承

抽取：推荐，将Feign的Client抽取为独立模块，并且把接口有关的的POJO，默认的Feign配置都放在这个模块中，给所有消费者使用



​		**7）、Feign远程调用时的日志级别有哪些？**

NONE：不记录任何日志信息，这是默认值。

BASIC：仅记录请求的方法，URL以及响应状态码和执行时间

HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息

FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。



​		**8）、如何优化Feign的调用性能？**

1：日志级别尽量用Basic

2：使用HttpClient或OKHttp代替URLConnection（这个URLConnction是默认实现，不支持连接池）



​		**7）、Feign的默认超时时间是多久？重试次数是几次？**

超时时间是一秒，重试是一次



​		**8）、Dubbo服务注册与发现的原理？（官方原理图）**

内部结构角色：服务提供者，注册中心，服务消费者，监控中心，运行容器

Consumer：调用远程服务的服务消费者

Registry：服务注册与发现的注册中心

Provider：暴露服务的提供方

Monitor：统计服务和调用次数和调用时间的监控中心

流程：

服务容器负责启动，加载，运行provider

provider在启动时，向registry注册自己提供的服务

Consumer在启动时，向registry订阅自己所需要的服务

registry返回provider地址给Consumer，Consumer会保存地址列表，如果有更变registry将基于长连接推送变更数据给Consumer

Consumer从privider提供的地址列表中，基于自己的负载均衡算法，选一台进行调用，如果调用失败，再选另一台

Consumer和provider，在内存中调用的次数和时间，定时每分钟发送一次统计数据给monitor

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE24547c31e901e29265d0d7863a8451cb/8473)



​		**9）、Dubbo负载均衡策略有哪些？默认是哪种？**

 random ：按权重随机，默认值。按权重设置随机概率。（默认）

 roundrobin ：按权重进行轮询调用。

 leastActive：最少活跃调用数，Dubbo认为活跃度最小的性能会更高，而相同活跃数进行随机调用。

 consistentHash：一致性 Hash，相同参数的请求总是发到同一提供者。



​		**10）、Dubbo支持哪些通信协议？默认是哪种？一般用哪种协议？有什么好处？**

dobbo协议，rmi协议，webserver协议，http协议，hession协议，thrift协议，memache，redis，rest协议

默认是dobbo协议

好处：适合大并发小数据量的服务调用，以及服务消费者远大于服务提供者的情况，缺点是不适合传送大数据包服务



​		**11）、注册中心挂了影响服务调用吗？为什么？**

会继续通信，注册中心全部宕机，会依靠本地缓存通讯



​		**12）、Dubbo启动检查如何设置？多版本支持如何设置？**

启动检测设置：在yml里面配置，consumer：check=false 是关闭

多版本设置：在服务实现类的@DubboService注解上指定版本 version=”版本号“

​                     在消费者调用时@DubboReference后指定版本version=”版本号“



​		**13）、Dubbo的默认超时时间是多久？重试次数是几次？**

超时时间一秒，重试次数两次



​		**14）、Dubbo进行服务注册和发现的核心注解是哪个？**

服务注册@DubboService   服务发现@DubboReference



​		**15）、Dubbo服务如何进行监控和管理？**

在gitHub上下载Dubbo-admin

​	**3、注册中心**

​		**1）、Eureka**

​			**1、eureka是属于什么体系的技术（Spring Cloud）**

springcloud



​			**2、eureka技术体系有哪些角色？（服务端用作注册中心，客户端用作微服务）**

服务器用作注册中心，客户端用作微服务

**Eureka server  ，Eureka Client**



​			**3、eureka的自我保护机制是什么？什么时候开启？为什么开启？开启了会发生什么？**

**自我保护机制**：为了防止当微服务状态正常，网络分区故障，导致实例被误杀而提供的一种保护机制

**什么时候开启**：Eureka server 在运行期间会去统计心跳失败比例在15分钟内是否低于85%，如果低于85%，Eureka server则会进入自我保护机制

**开启了会发生什么：**1）Eureka不再从注册列表中移除因为长时间没收到心跳而应该剔除的服务

​                                 2）Eureka仍然会接收新服务的注册和查询，但是不会同步到其他节点上，保证当前节点依然可用

​                                 3）当网络稳定时，当前实例新的注册消息会被同步到其他节点中



​			**4、eureka作为注册中心的原理是什么？心跳检测某个服务是否健康的原理详细说下？**

**原理**：Eureka server主要对外提供三个功能

**服务注册：**服务提供者启动时，会通过Eureka Client向Eureka Server注册消息，Eruka Server会储存该服务的信息，内部有两层缓存机制来维护整个注册表

**提供注册表：**服务消费者在调用服务时，如果Eureka Client没有缓存注册表的话，会从Eureka Server获取最新的注册表

**同步状态**：Eureka Client通过注册，心跳机制，和Eureka Server同步当前客户端的状态



​			**5、eureka集群是属于AP还是CP？(AP)**

​			

​		**2）、Nacos**

​			**1、nacos是属于什么体系的技术（Spring Cloud Alibaba）**

Spring CloudAlibaba



​			**2、nacos作为注册中心的原理是什么？**

**服务实例启动时到服务注册表，服务消费者可以查询服务注册表来获得可用实例，**



​			**3、nacos如何确定唯一的一个服务?（通过namespace、group、service、集群唯一确定一个服务）**

Nacos提供了**namespace来实现环境隔离**，Nacos中可以有多个namespace，**namespace下可以有group，service等，不同namespace之间相互隔离**



​			**4、nacos中namespace、group分别的作用是什么？**

namespace可以相当于一个空间，空间里面有group，service

gorup是分组，一般都是默认分组



​			**5、nacos和eureka的异同有哪些？**

共同点：**都支持服务注册，服务拉取，服务提供者心跳方式做健康检测**

不同点：**Nacos支持服务端主动提供检测提供者状态**，**临时实例采用心跳检测模式，非临时实例采用主动检测模式**

​              **Nacos临时实例心跳不正常会被剔除，而非临时实例不会**

​              Nacos支持服务列表变更的消息推送模式，服务列表更新更及时

​              **Nacos集群默认采用AP模式**，**当集群中存在非临时实例时，采用CP模式**。**Eureka采用AP模式**



​			**6、nacos的临时节点和非临时节点有什么区别？**

临时实例：如果实例出现宕机超过一定时间，**会从服务列表剔除，默认类型**

非临时实例：如果实例宕机，**不会从服务列表剔除**



​			**7、nacos集群是属于AP还是CP？(AP或CP)**

没有非临时实例时时AP，如果存在非临时实例就是CP



​			

​		**3）、Zookeeper**

​			**1、Zookeeper的内部结构是什么？**

zookeeper的数据模型很像树，树由节点组成，里面储存数据，节点叫做Znode，znode的引用方式是路径引用，类似文件路径，这样的层级结构让每一个znode节点拥有唯一的路径

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE16b580b345ab00fc0e174b756d021147/8188)



​			**2、使用Zookeeper作为分布式事务锁的原理是什么？**

原理：Zookeeper有一个特性，就是多个线程去Zookeeper里面去**创建同一个节点**的时候，**只会有一个线程去执行**



​			**3、Zookeeper集群属于AP还是CP？(CP)**

cp



​			

​	

​	**4、配置中心**

​		**1）、实现配置中心都可以使用哪些技术？**

Spring-Cloud-Config，Nacos



​		**2）、使用nacos作为配置中心，如何实现热更新？**

方式一：在@value注入的变量所在类添加**@RefreshScope**

方式二：使用**@ConfigurationProperties**注解代替@Value



​		**3）、nacos作为配置中心，为什么需要用到bootstrap文件？**

微服务拉取Nacos管理的配置，并且与本地的Application.yml配置合并，才能完成项目的启动

如果尚未读到Application.yml，又如何得知Nacos地址呢，所以spring引入了一个新的配置文件，**bootstrap，这个文件会在Application之前读取**



​		**4）、远程配置文件和本地配置文件属性加载优先级是什么样的？**

远程带环境的配置>远程共享配置>本地配置

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE011fbca3748af0f8c3b38db21d221b63/8251)



​		**5）、使用配置中心的好处是什么？能解决什么问题？**

如果没有配置中心，将会出现很严重的问题

- **安全性**：配置跟随源代码保存在代码块中，容易造成配置泄漏
- **时效性**：修改配置，需要重启服务器才能生效
- **局限性：**无法动态调整，如日志开关，功能开关

有了配置中心之后这些问题都能解决



​	

​	**5、服务保护**

​		**1）、Hystrix**

​			**1、hystrix是属于什么体系的技术？（SpringCloud）**

Spring-Cloud



​			**2、hystrix可以用来干嘛？（服务熔断降级）**

服务熔断降级



​			**3、hystrix默认的触发熔断策略是什么？（5分钟之内服务调用异常比例达到一半或者失败次数超过20次）**

**五分钟**之内服务调用**异常比例达到一半或是失败次数超过20次**



​			**4、hystrix的隔离是基于什么？（线程池隔离【低扇出】）**

**线程池隔离**，底扇出



​		**2）、Sentinel**

​			**1、sentinel可以用来干嘛？（限流、隔离、熔断、降级）**

限流，熔断，降级，隔离



​			**2、什么是微服务雪崩现象？如何解决微服务雪崩问题？**

雪崩状态：微服务之间**相互调用**，因为调用链中的**一个服务故障**，引起**整个链路都无法访问**的情况

解决：**预防层面使用限流，问题解决层面可以用超时处理，舱壁模式也就是隔离，熔断和降级**



​			**3、sentinel的限流模式有哪些？分别的运用场景是什么？**

**限流模式有直联，关联，链路，限流效果有快速失败，warm up，排队等待**

- **直联**：统计当前的资源请求，触发阈值时对该资源进行限流
- **关联**：统计当前资源相关的另一个资源，触发阈值时，对当前资源限流
- ​          **场景**：比如用户支付时需要修改订单状态，同时用户要查询订单，查询和修改操作会去抢数据库锁，产生竞争。业务需求是优先支付和更新订单业务，因此当修改订单业务触发阈值时，对查询订单业务限流
- **链路**：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流
- ​          **场景**：查询商品和创建订单业务，两者都需要查询商品，这个时候业务需求是优先满足创建订单，这时就可以对查询商品做限流



​			**4、sentinel的限流效果有哪些？分别的运用场景是什么？**

- **快速失败：**达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。是默认的处理方式。
- **warm up：**预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。
- ​                  **场景**：预热启动 ，当一个服务刚刚启动时，一切资源未能初始化，如果直接将QPS跑到最大值，会导致宕机，这个时候就需要warm up      
- **排队等待：**让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长
- ​                  **场景**：快事失败和 warm up在超出QPS阈值时都会直接抛出异常，而排队等待则会让所有请求进入一个队列中，按照阈值运行的时间间隔依次执行，后面的请求必须等待前面的执行完成



​			**5、sentinel支持对热点参数进行限流吗？**

支持



​			**6、实现微服务调用隔离有两种方式（信号量隔离和线程池隔离），区别是什么？sentinel是使用的哪种？**

**隔离方式：**信号量隔离和线程池隔离，sentinel默认采用的是信号量隔离

区别：

**信号量隔离**：**优点**：轻量级，无额外开销  **缺点**：不支持主动超时，不支持异步调用 

**线程池隔离**：**优点**：支持主动超时，异步调用  **缺点**：线程的额外开销大

当然sentinel也可以实现线程隔离，就是开启舱壁模式



​			**7、什么是熔断？熔断的原理是什么？什么时候会触发sentinel的熔断？断路器的三种状态是哪些？是怎样进行切换的？**

**什么是熔断**：拦截访问该服务的一切请求，当服务恢复时，断路器会放行访问该服务的请求

**原理：**由断路器统计服务的异常比例，异常数，慢请求比例，如果超出阈值就会熔断该服务

断路器三种状态：

**closed：关闭状态**，断路器会放行所有请求，并开始统计异常比例，异常数，慢请求比例，**超过阈值则会切换到open状态**

**open：打开状态，**服务调用将会熔断，访问熔断服务的请求会被拒绝，快速失败，直接走降级逻辑，**open状态5秒后会进入half-open状态**

**half-open：半开状态**，**放行一次请求如果请求成功切换到closed状态，请求失败切换到open状态**



​			**8、什么是降级？如何实现降级？**

降级：可以理解为，我访问这个服务失败了，但是又不能直接给用户显示出来，这个时候给一个别的画面给用户看，可以是404，也可以是请稍后

**实现降级：客户端定义降级方法，方式由两种**

​                  **1：FallBackClass**

​                  **2：FallBackFactoryClass（一般用这个好点，可以直接获取服务端抛出的异常）**



​			**9、sentinel授权规则是用来干什么的？**

**对请求方**来源做**判断和控制**，有**黑白名单两种方式**，可以让**网关来访问该资源，禁止服务器直接访问**



​			**10、sentinel的规则持久化方式有哪些？一般使用哪种？**

**原始模式**：**Sentinel默认方式**，将规则保存到内存中，重启服务会丢失

pull模式：控制台将配置推送到远程控制中心，如Nocas

push模式



​			

​	

​	**6、网关**

​		**1）、网关有什么作用？在你们项目中用网关来干嘛了？**

把网关当作防火墙，一切访问服务的连接都要经过网关，是所有微服务的入口

网关的作用：权限控制，路由和负载均衡，限流



​		**2）、网关的核心技术点有哪些？**

路由，过滤工厂，断言工厂



​		**3）、网关的路由是用来干嘛的？分为哪几种？**

路由就是把这个拦截到访问的网址后，校验这个网址后去访问我们微服务的真实配制的路径

种类分两种：静态路由，动态路由



​		**4）、网关的过滤器是用来干嘛的？分为哪几种？**

过滤器可以对进入网关的请求微服务返回的响应做处理

分为三种：默认过滤器，局部过滤器，全局过滤器



​		**5）、网关局部过滤器和全局过滤器的区别有哪些？**

局部过滤器由内置的三十一种局部过滤器工厂，可以针对某个路由配置，或针对全部路由的默认过滤器

全局过滤器需要自己通过代码实现，实现Filter方法，执行顺序要用过order接口或是注解，一般用来定义各个web服务的公共逻辑，如用户鉴权，日记记录等



​		**6）、网关中局部过滤器、默认过滤器、全局过滤器的执行顺序是什么？**

先看order属性，order属性越小越先执行，如果一样执行顺序为默认，局部，全局



​		**7）、加入网关后，访问一个链接，你们项目的执行流程是什么？**

geteway Client向geteway Server发送请求

请求会被HttpWebHandlerAdapter进行提取组装成网关上下文

将网关上下文传递到DispatcherHandler，它负责将请求发送给RoutePredicateHandlerMapping

RoutePredicateHandlerMapping负责路由查找，并根据路由断言判断路由路由是否可用

如果断言成功，由FilteringWebHandler创建过滤器链并调用

请求一次会经过preFilter—微服务—postFilter，最终返回响应



​		**8）、定义全局过滤器需要实现哪几个接口？**

实现filter接口和order接口



​		

​	

​	**7、分布式事务**

​		**1）、什么是本地事务？什么是分布式事务？**

本地事务：无需跨越多个服务或者数据源的单体事务，一般都是由spring控制

分布式事务：指一个业务跨越多个服务或数据源，每个事务叫分支事务，要保证所有分支事务，要么全成功，要么全失败



​		**2）、什么是CAP定理？为什么必须保证P？为什么在保证P的前提下只能保证C或者A其中一个？**

CAP：P必须满足，C或A满足其中一个

C：数据一致性，任何时候，访问任何节点返回的数据都是一致的

A：服务可用性，任何时候，访问任何节点都要能够得到响应

P：分区容错性，因为网络故障或其他原因导致分布式系统中部分节点与其他节点失去连接，要形成独立分区，出现分区后整个系统也要持续对外提供服务



​		**3）、什么是BASE理论？**

Basically Avalible（基本可用）：分布式系统出现故障时，允许损失部分可用性，保证核心可用

Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态

Evantually Consistent（最终一致性）：虽然无法保证强一致，但在软状态结束后，最终达成数据一致



​		**4）、seata解决分布式事务的三个角色以及分别的作用什么？**

TC 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚

TM 事务管理者：定义全局事务范围，开始全局事务，提交或回滚

RM 资源管理者：管理分支事务处理的资源，与TC交谈注册分支事务和报告分支事务，并驱动分支事务提交或回滚



​		**5）、seata解决分布式事务的四种模式**

TA：强一致性分阶段事务模式，牺牲了一定的可用性，无业务入侵

AT：最终一致的分阶段事务模式，无业务入侵，也是Seate默认模式

TCC：最终一致的分阶段事务模式，有业务入侵

SAGA：长业务模式，有业务入侵

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE1e4f9e2a20f65fcd53d35d80b0d76b29/9270)



​		**6）、XA模式特点、原理以及应用场景？优缺点有哪些？**

TA：强一致性分阶段事务模式，牺牲了一定的可用性，无业务入侵

原理：

- ​        第一阶段：
- ​                         TM开启全局事务，调用分支事务
- ​                         TC接收开启全局事务请求
- ​                         RM将分支事务注册到TC，执行本地SQL但不提交，将本地事务状态报告给TC
- ​        第二阶段：
- ​                         TM等一阶段所有分支事务执行完，发起提交/回滚全局事务
- ​                         TC接收全局事务提交/回滚请求，查询所有的分支事务状态，对RM发起提交/回滚命令
- ​                         RM依赖数据库，提交/回滚当前的分支事务

优点：强一致性，无代码入侵，简单

缺点：强依赖于关系型数据库实现回滚，性能较差



​		**7）、AT模式特点、原理以及应用场景？优缺点有哪些？有可能会出现什么问题？如何解决？**

AT：最终一致的分阶段事务模式，无业务入侵，也是Seate默认模式

原理：

- ​        第一阶段：
- ​                         TM开启全局事务，调用分支事务
- ​                         TC接收开启全局事务请求
- ​                         RM将分支事务注册到TC，执行本地SQL提交，执行前拍一个快照Undo-log，将本地事务状态报告给TC
- ​        第二阶段：
- ​                         TM等一阶段所有分支事务执行完，发起提交/回滚全局事务
- ​                         TC接收全局事务提交/回滚请求，查询所有的分支事务状态，对RM发起提交/回滚命令
- ​                         RM依赖于Undo-log快照数据，提交/回滚当前的分支事务

优点：一阶段可用直接提交事务，释放资源，性能较好。利用全局锁实现读写隔离，没有代码入侵

缺点：二阶段属于软状态，属于最终一直。框架的快早功能也会影响性能，但是比XA也好很多

可能出现的问题：脏写，当全局事务1提交修改的数据后，此时全局事务2又过来修改了这条数据 后续阶段二全局事务1需要利用快照进行回滚，将全局事务2的所有修改进行了覆盖

如何解决：seata内部提供了全局锁的概念（需要在seata server新增一张全局锁的表但是全局锁有可能导致死锁（内部通过限制获取全局锁的次数来解决：30次/10ms）



​		**8）、重点：TCC模式特点、原理以及应用场景？优缺点有哪些？有可能会出现什么问题？什么是空回滚和业务悬挂，如何解决？**

TCC：最终一致的分阶段事务模式，有业务入侵

原理：和AT一样，不过TCC时依靠人工编码来实现数据恢复，属于最终一致(AP)

优点：一阶段直接提交事务，释放资源性能好。相比AT无需生成快照和全局锁，性能最好。不依赖数据库事务，而是依赖补偿操作，可以用于非事务性数据库

缺点：代码入侵，便要人为编写Try，Confirm，Cancel接口。软状态，最终一致性。需要考虑Confirm和Cancel失败的情况，需要做幂等性处理

问题：空回滚和业务悬挂

空回滚解决：

- 问题描述：当某分支事务的try阶段阻塞时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，则就是空回滚。
- 问题解决：执行cancel操作时，应当判断try是否已经执行，如果尚未执行，则应该空回滚。

业务悬挂解决：

- 问题描述：对于已经空回滚的业务，之前被阻塞的try操作恢复，继续执行try，就永远不可能 confirm或cancel ，事务一直处于中间状态，这就是业务悬挂。
- 问题解决：执行try操作时，应当判断cancel是否已经执行过了，如果已经执行，应当阻止空回滚后的try操作，避免悬挂



​		**9）、SAGA模式特点、原理以及应用场景？优缺点有哪些？**

SAGA：长业务模式，有业务入侵

原理：分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。

优点：一阶段直接提交事务，无锁，性能好。不用编写TCC的三个阶段，实现相对简单。事务参与者可以基于事件驱动实现异步调用，吞吐高

缺点：没有锁和事务隔离，会有脏写。软状态持续时间不确定，时效性差

**九、ElasticSearch**

​	**1、什么是ES？由什么语言编写？和Lunce的关系？什么是ELK？**

什么是ES：高性能，高扩展，分布式，支持海量数据分析，搜索，计算的搜索引擎

java语言编写，前身是lucene

ELK：是一个围绕ElasticSearch的技术栈，包含ElasticSearch，logstash，Kibana



​	**2、ES的核心概念有哪些？什么是索引？什么是文档？文档格式是什么？什么是映射？什么是DSL？**

索引：index，同一个类型文档的集合，相当于msql的表

文档：document，josn格式的数据，相当于msql的行（row）

字段：field，一个个的字段，相当于msql的列（Column）

映射：mapping，对索引结构的约束，相当于msql的表结构（schema）

DSL：json风格符合restful风格的语句



​	**3、什么是倒排索引？倒排索引建立过程？**

什么是：在文档增删改的时候对文档进行合理化分词

过程：形成一个不重复的词条列表，每一个词条对应一个文档ID，将来根据文档找ID，在根据ID找到对应的文档，涉及了两次btree查询



​	**4、ES有哪些数据类型？keyword和text有什么区别？**

字符串：test（可分词的文本），keyword（精确值，例如：品牌，国家，ip）

数值：long，integer，short，byte，double，float

布尔：boolean

日期：date

对象：Object



​	**5、重要：说说用户输入框输入查询条件 进行ES搜索的底层原理过程**

1. 客户端发送请求到coordinate node
2. 协调节点将搜索请求转发到所有shard对应的primary shard或replica shard
3. 每个shard将自己的查询结果（就是一些doc id），返回给协调节点，由协调检点进行数据合并，排序，分页，产出最终结果
4. 由协调节点，根据doc id去各个节点上拉取document数据，最终返回给客户端



​	**6、ES分词器适合在什么字段上使用？分词器在ES中的使用场景有哪些？（建立倒排索引时对文档分词和用户搜索时对搜索条件分词）**

分词器一般在全文检索上使用

场景：百度输入框



​	**7、你们分词器用的哪种？为什么要自定义拼音分词器？为什么搜索时不能用拼音分词器？**

自定义分词器

由于客户端面对国人，需要有拼音分词器，但由于默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。

​        **8、ES有哪些查询类型，分别用在什么场景？如何实现复合查询？要给指定的数据进行加分如何实现？**

查询类型：全文检索，精确查询，地理坐标查询，复合查询

如何实现复合查询：符合查询里面有算分函数查询，布尔查询，在query模块后加一个functions，加上函数条件即可实现



​	**9、ES能对搜索结果进行哪些处理？如何实现高亮？**

排序，分页，高亮

实现高亮：高亮是对关键字高亮，搜索条件必须带有关键字，默认情况下高亮的字段必须与搜索指定的字段一样，否则无法高亮，如果一定要对非搜索字段高亮，需要添加一个属性“required_field_match=false”

高亮则是在和qeury同一级上添加highlight属性，在fields属性里面添加高亮字段



​	**10、ES有哪些聚合查询？**

常见的聚合操作：

bucket（桶）：用来对文档做聚合操作

metric（度量）：用来计算一些值，例如最大最小值，平均值

pipeline（管道）：其他聚合的结果为基础做聚合



​	**11、ES如何实现自动补全查询**

由于是对于国人的搜索引擎上的补齐，需要的是pinyin分词器



​	**12、如何自定义分词器？**

首先要知道分词器分为三部分，character filter在tokenizer之前对文本进行处理例如删除字符和替换字符，tokenizer将文本按照一个规则切割成词条，tokenizer filter将tokenizer输出的词条做进一步处理，例如大小写转换，同义词处理，由于默认的拼音分词器会将每个汉字单独分为拼音，而我们希望是每个词条形成一组拼音，需要对拼音分词器做个性化定制，tokenizer部分选择ik_max_word分词器，filter：“py”，然后在自定义一个tokenizer filter 过滤器名称py，“type”：pinyin分词器，后面在根据自己需要的业务调整pingyin分词器的属性	

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE8db8b4a154d1733c396881493ea82dd6/9571)



​	**13、如何实现es与mysql的数据同步？**

举例三种方案：

1. 同步调用
2. MQ异步调用
3. 监听binlog



​	**14、es集群节点有哪些类型？分别的职责是什么？**

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE34b2cc00bbe00326f9745df71ad619e4/9629)

master node：对CPU要求高，但是对内存要求低

date node：对CPU和内存要求都要高

coordinating node：对网络宽带，CPU要求高



​	**15、什么是es脑裂问题？**

假设有三个node，主节点与其他节点失联，这时另外两个节点会认为主节点宕机了，会推举新的主节点出来，当新的主节点诞生后，此时之前的主节点又恢复过来。这样就会让失联之前的主节点和推举的主节点自成两个集群，出现数据差异

解决：要求选票超过（节点数量+1）/2，因此最好节点的数量是奇数，在ES7.0以后就默认该配置了，一般不会出现



​	

**十、Docker**

​	1、什么是Docker？优点是什么？有哪些核心概念？



​	2、镜像操作命令有哪些？

​		拉取、推送、查看、查看所有、删除、删除所有、制作镜像、导出镜像、加载镜像

​	3、容器操作命令有哪些？

​		查看所有、查看正在运行的容器、删除、强制删除、创建容器、创建并运行、

​		启动容器、停止容器、重启容器、暂停容器、恢复容器、进入容器

​	4、数据卷操作命令有哪些？

​		创建数据卷、查看单个数据卷详情、查看数据卷列表、删除数据卷、删除未使用的数据卷、创建容器时挂载数据卷

​	5、docker如何自定义镜像？docker file的语法是什么样的？

​	6、docker compose是干嘛的?语法是什么样的？有那些数据类型，基本数据类型有那些，占多少字节，多少位，引用数据类型又有那些？

数据类型有：逻辑类boolean。文本型char。整数型byte，short，int，long。浮点型float单精度默认小数位6-7，double双精度

| 基本类型    | 字节           | 二进制位数 | 引用类型      |
| ------- | ------------ | ----- | --------- |
| boolean | 实际按1，本来是1bit | 1     | Boolean   |
| byte    | 1            | 8     | Byte      |
| char    | 2            | 16    | Character |
| short   | 2            | 16    | Short     |
| int     | 4            | 32    | Integer   |
| long    | 8            | 64    | Long      |
| float   | 4            | 32    | Float     |
| double  | 8            | 64    | Double    |

### **2：封装继承多态**

java语言有几大特性，分别怎么理解？（封装继承多态的好处）

特性：封装继承多态

1：封装：封装是指属性私有化，根据需要提供get，set方法来访问属性。既隐藏具体属性和实现细节，仅对外开放接口，控制程序中属性的访问级别。

目的：增强安全性和简化编程，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员

2：继承：继承是指将多个相同的属性和方法提取出来，新建一个父类。Java中一个类只能继承一个父类，且只能访问权限非private的属性和方法。子类可以重写父类中的方法，命名与父类同名的属性。

目的：代码复用

3：多态：多态实现分为两种，设计时多态和运行时多态。体现为父类引用变量可以指向子类对象

编译时多态：既重载，在同一个类中方法名相同而参数不同（返回值可以相同也可以不相同）

运行时多态：既重写，是子类对父类允许访问方法的实现过程进行重新编译，返回值和形参都不能改变。



### **3：权限修饰符**

java中权限修饰符有那些，都能加在什么地方，分别代表什么意义

|      | public | protected | defalit(默认) | private |
| ---- | ------ | --------- | ----------- | ------- |
| 同一个类 | √      | √         | √           | √       |
| 同一个包 | √      | √         | √           | ×       |
| 子父类  | √      | √         | ×           | ×       |
| 不同包  | √      | ×         | ×           | ×       |

### **4：abstract修饰符**

abstract修饰符一般来修饰类和方法，修饰类会变成抽象类，修饰方法会变成抽象方法

抽象类不能被实例化，但有自己的构造方法

抽象类中可以没有抽象方法，但包含了抽象方法的类必须要被定义成抽象方法

如果子类没有实现父类中的所有抽象方法，也要被定义成抽象类

抽象类不能被final修饰，被final修饰的类无法被继承

抽象方法不能被private修饰，因为子类必须重写父类方法

抽象方法不能被static修饰，因为被static修饰可以直接通过类名调用，抽象方法没有主体

抽象方法没有方法体，一个方法没有方法体必须被定义为抽象方法

### **5：final修饰符**

final修饰基本类型变量的时候，该变量不能被重写赋值

final修饰引用类型变量的时候，该变量不能重新指向其他对象

final修饰的方法为最终方法，该方法不能被重写

final修饰的类为最终类，不能被继承

### **5：static修饰符**

1：申明了静态方法或者变量，值是要放在方法区的。因为方法区是一个共享数据区，不管什么变量访问它，都是同一份

2：在静态方法中不能直接访问实例方法和实例变量

3：在静态方法中不能使用this，super关键字

4：静态方法不能被abstract修饰

静态成员变量可以使用类名或者是对象进行访问，非静态成员变量只能使用对象进行访问

静态函数可以直接访问静态成员，但不能够直接访问非静态成员，非静态函数可以直接访问金泰和非静态成员。

当类被加载时，静态代码块只执行一次，类中不同的静态方法代码块按它们在类中出现的顺序被依次执行



单例模式

包装模式

工厂模式

观察者模式

### **7：重载和重写的区别**

方法重载和重写都是实现多态的方式

重载：编译时多态，发生在同一个类中，同名的方法如果有不同的参数列表（参数类型不同，参数个数不同，可以有不同返回值类型）被视为重载

重写：运行时多态，发生在子父类中，是子类对父类允许访问方法的实现过程进行重写编译，

所以方法名，参数列表，返回值都要相同



一般用spring async 机制   底层是线程池

先开启

@Enable Async 

然后在方法上打@Async 



### **8：接口与抽象类**

抽象类：被abstarct关键字修饰的类为抽象类，修饰的方法为抽象方法，只有声明没有方法体 

1. 抽象类不能被实例化，只能被继承
2. 包含抽象方法的一定是抽象类，但是抽象类不一定有抽象方法
3. 抽象类中的抽象方法的修饰符只能为public或者protected，默认为public
4. 一个子类继承一个抽象类，子类必须实现父类所有父类所有抽象方法，否则子类也会被定义为抽象类
5. 抽象类可以包含属性，方法，构造方法，但是构造方法不能被实例化，主要用途是被子类调用

接口：被interface关键字修饰

1. 接口可以包含变量。（1.8之后接口是可以出现非抽象方法的default方法，静态方法）
2. 接口支持多继承
3. 一个类可以实现多个接口
4. 1.8对接口的新特性：1：（default method）允许给接口添加非抽象方法实现，但必须使用default关键字修饰，定义了default的方法可以不被实现子类所实现，但只能被实现子类的对象调用，如果子类实现了多个接口，并且这些接口包含一样的默认方法，则子类必须重写默认方法。

​                                 2：（static method）使用static修饰一个方法，并提供实现，称为静态接口方法，静态接口方法只能通过接口调用

相同点：

1. 都不能被实例化
2. 接口的实现类，抽象类的子类 都只有实现了接口或抽象类中的方法后才能实例化

不同点：

1. 接口只有定义，不能有方法实现。而抽象类可以有定义与实现，方法可以在抽象类中实现
   2. 一个类可以实现多个接口，但一个类只能继承一个抽象类。接口可以实现多重继承
3. 接口强调特点功能的实现，抽象类强调所属关系
4. 接口只能包含抽象方法，静态方法，默认方法，私有方法，不能为普通方法提供方法实现，而抽象类可以包含普通方法
5. 接口只能定义静态常量，不能定义普通成员变量。抽象类既可以定义普通成员变量，也可以定义静态常量
6. 接口没有构造方法，抽象类可以包含构造方法

### **9：异常**

java异常体系是什么，运行时异常和编译异常有什么区别，常见的异常有那些

异常体系：Throwable是异常的超类，将异常划分为两类：Error和Exception。

Error：是程序中无法处理的错误，此类错误一般为JVM出现问题。通常由Virtual MachineError（虚拟机运行错误），NoClassDefFoundError（类定义错误）等

Exception：程序本身可以捕获的异常

1. 运行时异常：RuntimeException类及其子类表示在JVM运行期间可能出现的错误，比如（NullPointException）空指针异常，（ArrayIndexOutBoundException）数组下标越界。此类异常一般是由程序逻辑错误引起的。在程序中可以选择捕获，也可以不处理。
2. 编译时异常：除了RuntimeException及其子类之外的异常。比如（IOException），必须对该异常进行处理，否则编译不通过。

常见异常

1. ClassFormatError（类格式错误）
2. ClassCastException（类型转换异常）
3. NullPointException（空指针异常）
4. ArrayIndexOutBoundException（数组下标越绝）
5. ArrayStoreException（数组存储异常）
6. UnknownError（未知错误）
7. SQLException（操作数据库异常）
8. IOException（输入输出异常）



### **10：==和equals的区别**

1. ==是操作符，equals是方法
2. 对于基本类型变量来说（short，int，long，float，double等）只能使用==，因为这些基本类没有equals方法，对于基本类型变量的比较使用==，一般是比较他们的值
3. 对于引用类型来说（如String）才有equals方法，因为String继承了Object类，equals是Object类的通用方法。对于该类对象的比较，默认情况下也就是没有重写Object类的equals方法，这时使用==和equals比较是效果是一样的。都是比较他们在内存中的地址值，但是对于某些类来说，为了满足业务需求，会存在重写equals方法的情况，这时使用equals方法比较需要看具体情况，例如String类，使用equals方法会比较它们的值。

### **11：&（逻辑与）和&&（短路与）**

&会对所有的条件进行判断

&&判断第一个条件为false后，对后面的条件就不会进行判断了

### **12：|（逻辑或）和||（短路或）**

|会对所有的条件进行判断

||判断第一个条件为true后，对后面的条件就不会进行判断了

### **13：String可以修改本身么**

不可以

1.6中在String内部有value，offset，count这三个变量，并且没有提供set方法等公共方法来修改这些值，而且这三个变量是是被privete和final修饰的，所以一旦初始化，也就不能被改变了。

1.8时虽然内部只有value这个数组了，但是依然是被private和final修饰的，所以还是一旦初始化，也就不能被改变了。

### **14：String，StringBuffer，StringBuilder的区别**

运行速度快慢为：StringBulider>StringBuffer>String

String是字符串常量，而StringBuffer和StingBuilder均为字符串常量。String对象一旦创建后该对象是不可改变的，但后两者是变量是可以更改的。

线程安全上：StringBuffer是安全的，StringBuilder是不安全的

一个StringBuffer对象在字符缓冲区被多个线程使用时，StringBuilder中很多方法带有synchronized关键字，所以可以保证线程是安全的。但StringBuffer方法则没有该关键字。

### **15：valueOf和toSting的区别**

1. toString返回的是字符串，而valueOF返回的则是原对象
2. 因为toString为Object类中的public方法，严格意义上来说任何java对象都可以调用此方法，但在使用时要注意，保证Object不能为Null值，否则会抛出NullPointerException异常。
3. valueOf在内部会做非空判断

### **16：大量字符串拼接用+效率高吗**

为什么？应该用什么代替？为什么？

效率为什么不高：string对象为不可变对象，因此在字符串进行操作修改时，String对象总会产生新的对象。所以性能相对较差

应该用什么代替：在多线程的要保证线程安全的情况下用StringBuffer.append。在单线程的情况下可以用StringBuilder.append。

为什么用这个代替：StingBuffer和StingBulider实现原理：与String相似，StringBuilder类也封装了一个字符数组。与Sting不同的是，它并不是final的，所以他是可以修改的。另外与String不同的是，字符数组中不一定所有位置都已经被占用，他有一个实例变量，表示数组中已经使用的字符个数。该类继承了abstractStringBuilder类，其append 方法会直接拷贝字符串到内部字符数组中，如果字符数组长度不够，会进行扩展。

### **17：创建一个类的实例有哪些方式**

1. 用new语句创建对象
2. 运用反射，调用Class或者Constructor类的newInstance（）实例方法
3. 调用对象clone方法
4. 运用反序列手段，调用ObjectInputStream对象的readObject方法

### **18：java集合体系**

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCEb4f2eddcc88b06c5e39c07a33437523b/1280)

单列集合Collection为超类，下面有List，Queue，Set

双列集合Map为超类，下面有TreeMap，HashMap

### **19：List：有序，可重复**

1：ArrayList    优点：底层结构是数组，查询快，增删慢

​                        缺点：线程不安全，效率高



是进行位移，向右位移，拿着原来的容量10向右移2位，就是除以2，也就是10+5，扩容

Arrays.copy

2：Vector        优点：底层结构是数组，查询快，增删慢

​                        缺点： 线程安全，效率低

3：LinkedList  优点：底层数据结构是链表，查询慢，增删快

​                        缺点：线程不安全，效率高 





### **20：set：无序，唯一**

1：HashSet    底层数据结构是哈希表（无序，唯一）

如何保证元素唯一性？ 依赖两个方法 HashCode和equals

2：LinkedHashSet   底层数据结构是链表和哈希表（插入有序，唯一）

由链表保证元素有序

由哈希保证元素唯一

3： TreeSet   底层数据结构是红黑树（唯一，有序）

如何保证元素排序？ 自然排序，比较器排序

如何保证元素唯一？ 根据比较的返回值是否是0来决定







### **21：Map:双列集合**

Map为超类，下面下个实现类分别是HashMap，TreeMap，HashTable

1： HashMap  底层用哈希表，数据结构（链表+数组+（JDK1.8加入了红黑树）），允许Null值与Null键，键值唯一，但存取无序

如果是自定义对象需要重写HashCode和equals方法

JDK1.8之后的优化    搜索效率提高了，之前链表的复杂度是   

生成了一个entry初始化容量16的数组+链表的结构，使用容量大于0.75时，自动扩容2*n 

HashMap加入红黑树结构，当链表长度达到8或容器达到64时会自动转换为红黑树储存，用以提升元素操作性能。

为什么加载因子为0.75：当加载因子设置比较大，扩容的门槛提高，频率降低，占用空间较小，但是发生Hash冲突的几率会增大。当加载因子较小，扩容门槛降低因此会占用更多空间。但储存的元素比较稀疏，发生Hash冲突可能性变小，所有综合以上取了0.5-1.0的中间值

2：LinkedHashMap   继承了HashMap，底层使用哈希表和链表实现，元素唯一有序

3：HashTeble  底层用数组+链表，不允许Null作为key和value，线程是安全的

4：TreeMap   数据结构红黑树，元素唯一且能按照给定的规则排序，键值唯一，允许Null键值

### **22：红黑树**

特征：任意一个节点所包含的键值，大于左边的键值，小于右边的键值

特点：

1. 每个节点必须是红色或者是黑色
2. 根节点必须是黑色
3. 红色的节点，他的叶节点只能是黑色
4. 从任意节点到其每个叶子节点的所有路径都包含相同数量的黑色节点

依靠左旋和右旋保持平衡

### **23：concurrentHashMap（保证安全）**

原理是什么？

ConcurrentHashMap的锁分段技术：因为HashTable的线程都必须去竞争同一把锁，导致线程效率低下，从而诞生了ConcurretHashMap锁分段技术，简洁的来说就是：假如容器中有多吧锁，每一把锁用于锁容器中的一部分数据，那么当多个线程访问容器中不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率。首先将数据分成一段一段，然后给每一份数据加上一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问。不能用整个ConcurrentHashMap加锁。

### **24：Socket是什么**

首先我们要知道，IP对应网络层，TCP对应传输层，HTTP对应应用层

IP/TCP的协议时传输层协议，主要解决数据如何在网络中传输，而HTTP则是应用层协议，主要解决如何包装数据

Socket实际上就是对IP\TCP协议的封装，他的出现只是为了让程序员更方便的使用TCP\IP协议栈而已，Socket本身并不是协议，他是应用层与TCP\IP协议通讯的中间抽象层，是一组调用接口。

应用程序可以通过它来发送或者接收数据，可对其想文件一样的打开，读写，关闭等操作。

套接字允许程序将I/O插入到网络中，并与网络中的其他应用程序进行通讯。网络套接字时IP地址与端口的组合。

### **25：IO/NIO/BIO/AIO是什么**

先了解什么时同步异步，阻塞与非阻塞

同步：就是发起一个请求调用后，被调用者未处理完成请求之前，调用不返回。

异步：就是发起一个请求后，立刻得到被调用者的回应表示已收到请求，但是并不会返回被调用结果。被调用者会通过回调机制来通知调用者其返回结果。

阻塞：阻塞就是发起一个请求，调用者一直等待结果返回。也就是当前线程会被挂起，无法从事其他任务。只有当条件允许之后才能继续。

非阻塞：就是发起一个请求，调用者不用一直等待结果返回，可以先去干其他事。

IO：为阻塞IO

BIO：为同步阻塞IO，吞吐量低，可靠性非常差。服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务器需要启动一个线程进行处理。

NIO：同步非阻塞IO，吞吐量中，可靠性差。服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。用户进程也需要是不是询问IO操作是否就绪。NIO三个核心概念，缓冲区，通道，选择器。

AIO：异步非阻塞IO，吞吐量高，可靠性高。在读写操作结束之前，允许进行其他操作的IO处理



​		

### **26：反射**

什么是反射？

java在运行状态下，对于任意一个类，我们能知道这个类的属性和方法，对于一个任意一个对象我们能够调用它的属性和方法。这个动态获取信息和动态调用对象为反射机制。 

有什么用？

在已知反射能够在运行时能够动态获取信息和动态调用对象，那么我们可以更灵活的编写代码，**代码可以在运行的时候装配，无需在组件之间进行源代码链接**，**降**低代码的耦合度，还有动态代理实现等等。

使用场景？

1. 模块化开发，通过反射去调用字节码文件
2. 动态代理设计模式也是采用反射
3. spring框架，sping通过xml配置模式状态Bean：将程序内的所有的xml或Properties配置文件加载入内存，java解析配置文件，得到里面的对应实体类的属性信息，然后利用反射机制根据这个字符串获得某个类的Class实例，然后在动态配置实例的属性
4. JDBC数据库连接，通过Class.forName加载数据区的驱动程序，（这一步是通过反射加载的），然后在通过DriverManager类进行数据库连接。在通过Connerction接口接收连接。

什么是暴力反射？

​	通过setAccessible方法，强行操作private修饰的属性或方法。

如果构造方法，普通方法，字段被private（私有）修饰，默认该类的外部是不允许访问的。

但是如果使用暴力反射的话，即使被private修饰也可以进行操作

原理：假设定义了一个A类和B类，A类里面有一个public字段和private字段，在B类里面new了一个A类的一个实例，这个时候我们可以通过反射获取a引用对象的共有字段，但A类其中有一个私有字段，我们无法获取，这时就要用到暴力反射，通过实例a的getClass方法，先获取到a所属类的字节码，然后调用getDeclaredField（私有字段变量名）获取A类所有字段，包括私有，此时虽然我们已经获取到了私有字段，但是无法查看私有字段的值，这个时候就要用到setAccessible（true）方法来暂时改变字段的私有特性，然后我们就可以使用get方法获取到A类私有字段的值了

### 27：算法

冒泡排序：这是一种最简单最直观的排序算法，将数列依据你指定的模样排序，例如左小右大它需要重复走访要排序的数列，一次比较两个元素的值，，在比较时如果发现他们的顺序错误就会将他们交换过来。对每一组相邻元素都会重复同样的动作，这步做完最后的元素将会是最大的值，之后在重复以上步骤，除了最后一个，持续对越来越少的元素重复以上步骤，直到没有一对元素需要比较。

选择排序：和冒泡类似，但是冒泡时通过相邻的两个元素进行比较，而选择排序则是通过对整体的选择，每一趟从前往后找，找出无序区的最大值或最小值，再将这个值交换到无序区的最前方。

快速排序：选数列的一个数作为基数，一般是数列的第一个数作作为基数L，然后在选数列的最后一个数作为R，大于基数的放右边，小于基数的放左边，然后重复进行操作。

### **27：JDK1.8新特性**

lambda表达式：

**作用：用于简化创建匿名内部类对象，表达式的代码块用于实现抽象方法的方法体，就相当于一个匿名方法。**

组成：**形参列表**，**箭头**，**代码块**

**Lambda表达式的目标类型必须是函数式接口**，（函数式接口代表**只包含一个抽象方法的接口**），使用Lambda表达式可以使代码变得更加简洁，紧凑。

Stream流：

什么是Stream流：Stream流是一个来自数据源的元素队列并支持聚合操作

**数据源：流的来源，可以是集合，IO，数组**

**聚合操作：类似SQL语句一样的操作**，比如filter，limit，map，find

API：**forEach：用来迭代流中的每个数据**

​         **map：用于映射每个元素对应的结果**

​         **filter：用于通过设置条件来过滤元素**

​         **limit：用于获取指定数量的流**

​         **sorted：用于对流进行排序**

### **28：IO流**

什么是IO流：

IO：输入（Input）/输出（Output）

流：**是一种抽象概念，是对数据传输的总称。**

**IO流就是用来处理设备间数据传输问题的**，例如：文件复制，上传，下载

分类：

按照数据流向：输入流：读数据

​                         输出流：写数据

按照数据类型：字节流，字符流

使用场景：如果是纯文本操作优先使用字符流，如果是图片，视频等二进制文件用字节流

字节类：

InputStream：这个抽象类是所有字节输入流的超类

OutputStream：这个抽象类是所有字节输出流的超类

字符流：

Reader：是所有字符输入流的父类

Wirter：是所有字符输出流的父类

### **29：分布式主键自增**

**uuid：**

优点：代码简单，直接调用API即可

缺点：无法排序，无法保证递增趋势。id存储空间相对较大

**数据库自增：**

优点：代码简单

缺点：不同数据实现方式不同，当数据库迁移时也需要做一些迁移。如果是单体架构，可能会出现单点故障问题。

**redis生成自增id**

优点：不依赖数据库，相对性能较高

缺点：如果项目中没有使用到redis需要额外加入组件，会增加系统复杂度

**雪花算法：**

优点：代码简单，可以利用Hutool工具

缺点：可能存在时钟回拨的问题

组成：

四部分组成，第一部分是第1位bit始终为0，保证这个ID为正数，

​                      第二部分是41位bit的时间戳可以精确到毫秒

​                      第三部分是10位bit组成的机器id，

​                                    其中10bit组成的机器id中，有5bit代表的是机房，5bit代表的是机器，总支持1024台机器

​                      第四部分是12位bit的一个计数序列号

​                                     这个是用来记录同一秒内产生不同的id。

​                                     12bit字节代表的是最大整数2的12次方，所以在一秒内可以产生4096个id。如果并发超过4096是不会有id重复问题，通过源码我们可以看到，如果他超过了这个最大值4096，它会阻塞，阻塞到下一秒在生成新的id

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE980600c458deca032eca1224112ce43a/2130)

# **二：JVM**

### **1：JRE和JDK的区别**

JRE：是java运行时的环境，包含了java虚拟机，java基础类库。是java程序运行所需要的软件环境，面向的是java程序使用者

JDK：是java开发工具包，是java程序所需的开发工具包，面向的是程序员。。

JDK包含了JRE，JRE包含了JVM

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE04c892ec2e97c6b9a3bffacbe63dc552/2199)

### **2：JVM内存模型是什么样**

内存结构根据线程数据共享分两块

线程隔离私有数据区：

​                                 **程序计数器，线程栈，本地方法栈**

线程共享数据区：

​                         	 **堆，方法区**

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE36271fb0fd277b0ef7525dc9d7ed3292/2201)

### **3：JVM双亲委派加载机制**

什么是双亲委派机制？

在知道双亲委派机制之前我们要先知道类加载器的作用

启动类加载器负责加载java_HOME的目录下的jre/lib目录下的类库

扩展类加载器负责加载java_HOME目录下jre/lib目录下的ext的子目录下的类库

应用程序类加载器负责加载用户路径Class.path上的类库就是我们写的程序大部分在这里加载

自定义加载器通过继承ClassLoader根据不同需求来实现自定义的类加载器

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE38918ef6897016115e582f6eff3494bd/2219)

工作过程：1：类加载器收到类加载请求

​                  2：把这个请求委托给父类加载器去完成，一直向上委托，直到启动类加载器

​                  3：启动类加载器检测能不能加载（利用findClass方法），能加载就结束，不能加载就会抛出异常交给子类加载器去加载。

​                  4：重复步骤三，但是一旦到自定义加载器还无法加载时，就会抛出ClassNotFound的异常

为什么JVM这么做？

JVM是根据全限定名来加载类的，如果出现两个或者多个全限定名完全一直的情况下，该选择加载哪个类，这就是双亲委派机制要做的事

有违反双亲委派的例子吗？

1. 在1.2之前，用户直接调用LoadClass方法。后改成FindClass方法，JVM官方推荐重写FindClass方法，而不是LoadClass方法，这样就依然可以符合双亲委派模型
2. 在操作数据库时，java提供接口，规范给数据库厂商，数据库厂商按照接口，规范自己实现自己的类库，在点进DriverManager源码会发现Drivermanager会主动对第三方Driver进行加载，扫描到java.sql.Driver类型的第三方类就使用ServiceLoader进行加载，而ServiceLoader内部则是使用当前线程Context的类加载器，一般线程Context加载器默认为Application类加载器加载，所以当前这个类加载器可以被正常加载了。

### **4：类加载的流程**

类加载的流程分为7步：加载>验证>准备>解析>初始化>使用>卸载

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCEa1d3d6f23dd18a66eaed932f94679fcf/2354)

加载：把代码数据加载进入内存中

验证：当JVM加载完Class文件后并在方法区创建相对应的Class对象，JVM便会启动对该字节             码的校验，只有符合JVM字节码规范的文件才会被	JVM正确执行

准备：当字节码文件校验后，JVM便会开始对类变量分配内存并初始化

解析：通过准备阶段后，JVM会针对类或接口，字段，类方法，接口方法，方法类型，方法句柄和调用限定符好7类引用进行解析。

初始化：JVM会根据语句循序对类对象进行初始化，触发初始化的五种情况

​             1：遇到New，getStatic，putStatic，invokeStatic

​             2：使用java.lang.refiect包的方法对类进行发射调用的时候

​             3：初始化一个类的时候，如果父类还没有初始化，需要先触发父类初始化

​             4：虚拟机启动，用户需要指定一个执行的类（main方法的类）会初始化该类

​             5：当使用JDK1.7动态语言支持时如果MethodHandle实例解析结果对应的方法句柄的类还未初始化时，会优先触发该类的初始化。

使用：完成初始化后，JVM便从入口方法开始执行用户的程序代码

卸载：当用户程序执行完毕后，JVM便开始销毁创建的Class对象最后负责的JVM也退出内存

### **5：GC的主要区域和GC机制**

JVM的GC的主要区域以及各自的GC机制是什么样的？

GC的主要区域：主要区域在堆和方法区

各自的GC机制：

​                        堆的GC机制：为了方便对象管理，内存分配，和GC堆分为新生代和老年代比例为1：2

​                        1）新生代：大部分new对象在此区域：包含Eden区+Survicor From区+Survicor To区 三个区的比例为 8：1：1

​                                          算法：当Eden区满了之后会触发一次GC，触发后会将还存活的对象从Eden区+from区/To区中用copy复制算法转移至from区/to区。这时还存活下来的对象会MG次数+1，当对象MG次数大于15时，该对象会移至老年去

​                        2）老年代：新生代经过15次GC之后的对象和新生代区存不下，比较大的对象会存在此区域

​                                          算法：当老年代没有内存空间容纳新对象时，会触发一次FC。首先Stop the World 暂停GC回收线程外额所有线程。然后使用标记—清除/整理算法，标出所有可以访问的对象并做个指定标记，之后便利堆内存，把未标记的对象进行回收。在此处标记可访问对象时还用到了可达性算法

​                                            可达性算法（GC Root）：从根节点出发，给所有可达对象做标记，解决了引用计数法对象相互依赖而无法被回收的问题。

​                                            标记—清除算法：效率较高，但是最后得到内存空间不是连续的

​                                            标记—整理算法：效率较低，但是最后得到内存空间时连续的

​                       方法区GC机制：这里主要存放运行常量池，静态变量，类信息，JTT编译后的代码等数据

​                       方法去的GC触发条件十分苛刻，必须符合以下三点才会被回收

​                             1）所有实例被回收

​                             2）加载该类的ClassLoader被回收

​                             3）Class对象无法通过任何途径访问，包括反射

### **6：JVM的GC算法都有哪些？**

确定垃圾算法：

1. 引用计数发：每被引用一次，引用次数+1。无法解决互相依赖引用而无法被清除问题
2. 可达性算法（GC Root）：从根节点触发，给所有可达对象打上标记。可以解决互相依赖引用而无法被清除问题

垃圾清除算法：

1. 标记清除：效率较高，但是最后得到内存空间不是连续的
2. 标记整理算法：效率较低，但是最后得到内存空间时连续的
3. 复制算法：将内存分为两块，每次只使用一块，回收时将存活对象复制到另一块中，简单高效，但是浪费内存空间。

# **三：spring&boot&MVC**

### **1：SpringIOC，控制反转**



SpringIOC即控制反转不是一种基数，是一种思

想，是一种面向对象编程的重要法则，IOC意味着将你设计好的对象交给容器管理，而不是传统的在你的对象内部直接控制，这种思想他能使我们设计出松耦合，更优良的程序。

何为反转；有反转就有正转：

正转：传统的应用程序是由我们自己在对象中主动控制去直接获取依赖对象

反转：是由容器帮我们查找及注册依赖对象，对象只是对被的接收依赖对象。

IOC对编程最大的改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，想要获取什么资源都是主动出击，但是在IOC中应用程序就变为被动了，被动等待IOC容器来创建并注入他所需要的资源

### **2：spirng Bean的生命周期**

Bean的生命周期分四阶段

1. 实例化 Instantiation
2. 属性赋值  Populate
3. 初始化  Initialization
4. 销毁  destruction

实例化和属性赋值是对应的构造方法和Setter方法的注入，初始化和销毁是用户能自定义扩展的两个阶段

### **3：IOC循环依赖问题**

什么是循环依赖：A依赖B B依赖A 就是循环依赖，当IOC都到A配置时，会先去实例化A，然后发现A依赖B，又去实例化B，结果又发现B依赖A，又会去实例化A，如果不解决循环依赖，容器就会无线执行上面的流程，直到内存溢出

知道什么是循环依赖后，我们首先要从Spring Bean的生命周期开始说，首先在sping Framework体系中我们的一个Bean它有一个BeanDefinition来构建的，（BeanDefinition可以理解为我们Sping的一个建模），springBean的生命周期大体分为以下几步，spirng容器启动扫描把类变成我们的BeanDefinition存到我们的beanDefinitionMap中，然后进行遍历，遍历完成后对我们的beanDefinition做一些基本的验证，是否单例，是否抽象是否懒加载，验证完成后他开始要实例化bean之前会去容器中就是我们的spring单例池当中获取一遍，看这个bean存不存在，如果不存在，再去看一下它有没有存在我们的二级缓存中（就是有没有提前被暴露）如果都没有代码会接着往下执行，创建A对象（如何创建：首先会去推断构造方法，把当前Spring Bean类当中的构造方法得到一个最佳的构造方法，推断完成后会通过反射去实例化一个java对象），创建对象后，会对该对象做一些初始化工作，（比如说是否要对这个Bean做一些BeanDefinition的合并，spring容器是否支持循环依赖，如果支持循环依赖会提前暴露一个当前java对象，也就是半成品所对应的ObjectFactory一个工厂类，把这个工厂类暴露。这个暴露就是会存到一个二级级缓存的Map当中）（属性填充，提前暴露）在填充属性当中，会发现A依赖B，这时会走B的生命周期流程，首先会对B做验证，判断B有无在单例池中，如果没有，会在判断B是否提前暴露，这时B肯定是没有提前暴露的，B也是会往下执行，B将会实例化，实例化之后会对B做一个初始化工作（把B提前暴露，属性填充）当B做属性填充时，发现B要填充A，但是此时A并没有被完整的实例化，所有并不能去填充A。所以此时要走一边获取A或者说创建A的流程，那么又会走刚刚之前走过一边第一次的A流程，在走A流程的过程当中，spring会发掘A已经提前暴露所有B能够拿到我们一个已经提前暴露好的ObjectFactory所产生的一个A对象，这样就完成了循环依赖（在此我们可以发现循环依赖时只默认支持单例的）



### **4、Spring三级缓存·**

/** Cache of singleton objects: bean name --> bean instance */

private final Map singletonObjects = new ConcurrentHashMap(256);

/** Cache of early singleton objects: bean name --> bean instance */

private final Map earlySingletonObjects = new HashMap(16);

/** Cache of singleton factories: bean name --> ObjectFactory */

private final Map> singletonFactories = new HashMap>(16);

**一级缓存**：单例对象缓存：当Bean已经被实例化、初始化之后，也就是完全创建完成后，会放入singletonObjects。

**二级缓存**：早期单例对象缓存：它是一个中间的过渡缓存，保存已经被实例化，但没有被属性注入的早期暴露Bean。 当Bean没有完全创建完成时，一级缓存中当然没有，尝试二级缓存中获取，如果二级缓存中没有，但是在三级缓存中有此Bean的创建工厂，意味着可以得到这个Bean的早期暴露对象，将Bean的工厂从三级缓存中移除，放入二级缓存中。

**三级缓存**：单例工厂缓存 ：它保存的是可以创建Bean的工厂。

### **5：AOP的理解，场景，底层*

理解：AOP意思为，面向切面编程，通过预编译的方式和运行期间动态代理实现程序功能统一维护的一种技术，是Spring框架中的一个重要内容，是函数式编程的一种衍生范型，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可用性，同时提高了开发效率。

五种通知类型：

1. 前置通知：Before advice 在连接点之前执行，前置通知不会影响连接点的执行，除非抛出异常
2. 正常返回通知：After returuing advice 在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行
3. 异常返回通知：After throwing advice 在连接点抛出异常后执行
4. 返回通知：After advice 在连接点执行完成后执行，不管是否抛出异常，都会执行返回通知中的内容
5. 环绕通知：Around advice 环绕通知围绕在连接点前后，比如一个方法调用前后。这是最强大的通知类型，能在方法调用前后自定义一些操作。

场景：

1. 记录日志
2. 监控方法运行时间
3. 权限控制
4. 缓存优化，例如第一次调用时查数据库，将结果存入Redis，第二次调用时直接从redis返回对象
5. 事务管理，调用方法前开启事务，调用方法后提交关闭事务

底层：JDK动态代理，Cglib动态代理

要理解AOP底层的两种动态代理首先要搞清楚什么是动态代理，动态代理用简洁的话说就是本来是我自己该做的事情，却请了别人来做，被请的人就是代理对象。例如春节回家要买车票，我请了我朋友帮我代买，我朋友就是代理对象。所以动态代理本质就是通过反射来产生一个代理对象

在java.lang.refiect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个接口就可以生成动态代理对象，JDK提供的代理只能针对接口做动态代理，而Cgbiib动态代理则更为强大，它可以对任意类生成代理对象，它的原理就是对目标对象进行继承代理。但如果目标对象被final修饰，那么该类无法被Cgblib代理

在AOP中如果被代理对象实现了接口，就会优先使用JDK代理，如果没有就会使用Cgblib代理

### **5：MVC的工作流程**

1. 用户发送请求至DispatcherServlet
2. DispatcherServlet收到请求调用HandlerMapping
3. HandlerMapping根据URL找到具体的处理器，生成处理器执行链（HandlerExcutionChain），里面包括了处理器拦截器（HandlerIntercepter）处理器对象（Handler）。一并返回给DispatcherServlet
4. DispatcherServlet根据Handler获取处理器适配器（HandlerAdapter），执行HandlerApdapter处理一系列操作，如参数封装，数据类型格式转换，数据验证等操作
5. HandleAdapter执行Handler完成后返回ModelAndView给DispatcherServlet
6. DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）
7. ViewReslover执行后返回具体View给DispatcherServlet
8. DispatcherServlet对View进行视图渲染，（将Model填充至VIew中）
9. 响应客户

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCEabb23bb22823be89adf2ed96267e6a3a/3098)

### **6：Spring事务的理解，隔离级别，传播行为，事务失效**

理解：Spring事务本质上就是数据库对事务的支持，没有数据库的支持，Spirng是无法提供事务功能的

事务特性ACID：原子性（Atomicity）要么全完成要么全失败

​                           一致性（Consistency）不管成功或失败，都要确保所属业务处于一致的状态

​                          隔离性（Isolation）每个事务都会隔离开来，防止数据损坏

​                          持久性（Durability）一旦完成，无论发生什么系统错误，结果都会不受影响，事务的结果会写到持久化容器中

隔离级别:

关于事务的并发可能出现的问题

1.脏读：一个事务读到另一个事务未提交的更新数据。 

2.不可重复读：一个事务两次读同一行数据，可是这两次读到的数据不一样。 

3.幻读：一个事务执行两次查询，但第二次查询比第一次查询多出了一些数据行。

| 事务隔离级别                 | 脏读   | 不可重复读 | 幻读   |
| ---------------------- | ---- | ----- | ---- |
| 读未提交（read-uncommitted） | 是    | 是     | 是    |
| 不可重复读（read-committed）  | 否    | 是     | 是    |
| 可重复读（repeatable-read）  | 否    | 否     | 是    |
| 串行化（serializable）      | 否    | 否     | 否    |

传播行为

1. propagation_required(需要/事务)：spring事务默认传播行为，如果存在事务则加入，不存在则创建新的
2. propagetion_supports(支持无事务)：存在事务则加入，不存在则以非事务方式运行
3. propagation_mandatory(强制必须有事务)：存在则加入，不存在抛出异常
4. propagation_requires new （新建需要）新建一个新的事务，如果当前存在事务，延缓当前事务
5. propagation_NOT_supported(不支持)以非事务状态运行，如果当前存在事务，暂停当前事务
6. propagation_never(从不 不能有事务)以事务状态运行，如果当前存在事务，则抛出异常
7. propagation_nested(嵌套 套娃事务)如果没有就新建，如果有就在当前事务中嵌套一个事务

事务失效

1. 未启用Spirng事务管理：要在启动类打上@EnableTransactionMangement注解
2. 方法不是Public类型，如果@Transaction用在了非Public方法上将失效
3. 数据源未配置管理，Spirng是通过事务管理来管理事务，不要忘记配置事务管理器，每个数据源都要配置
4. 自身调用问题，必须通过代理对象访问方法，事务才会生效。如果是用的this显然事务是会失效的
5. 异常类型错误，并不是所有异常Spring都会回滚事务，默认情况下只有RuntimeException和Error的情况下Sping才会回滚事务，当然我们也可以自定义回滚的异常
6. 异常被吞了，如果方法内部用了Try catch方法自己将异常给处理了，事务就不会回滚了
7. 业务和Spring事务必须同一线程



### **7：Spring核心注解及其作用**

1. Controller：在控制层表示该类是SpringMVC Controller处理器
2. Service；在业务逻辑层使用，标注这是业务层组件
3. Componnet：标注在一个类上，表示为Spring容器中的一个Bean
4. Aotuwried：把配置好的Bean完成属性，方法的组装，完成自动装配的工作
5. bean：意思是产生一个bean交给Spring容器管理
6. Configuration：声明当前为配置类
7. ComponnetScan：对Componnet组件进行扫描
8. Value：为对应的属性注入值 

### **8：Spring和SpringBoot关系**

SpringBoot只是对spring本身的拓展，消除了设置Spring应用程序所需的大量XML配置，使开发，部署更加方便



### **9：SpringBoot自动装配原理**

1. 在@SpringbootApplication里面里面有个EnableAutoConfiguration注解。这个注解就是实现自动装配的注解
2. 在这个注解里面可以发现有一个@Import导入了一个配置类AutoConfigurationImportSelector
3. AutoConfigurationImportSelector配置类里面有个LoadFactoryNameS方法，这个方法的作用就是来读取包中/项目中META—INF/Spring.factories文件
4. Spring.factories配置了自动装配类，比如mybatisplus为例，在里面就会有DruidDateSourceAutoConfiguretion这个自动装配类，这个类里面会根据条件去创建Bean。



### **10：SpringBoot核心注解** 

SpringBoot最最最核心的注解是@SpringBootApplication，在SpringBoot启动类上标识这是一个SpringBoot项目，用来开启SpringBoot的各项能力，其中这个注解又包含了三个核心注解，@SpringBootConfiguration

@SpringBootConfiguration 这个注解就是Configuration的变体，用来装饰springBoot的配置，装配所有的Bean事务，提供Spring的上下文环境

@EnableAutoConfiuration 这个注解是SpringBoot自动装配注解，开启这个注解后SpringBoot能根据当前类路径下的包或者是类来配置spingBean

@CompnentScan 这个注解是SpringBoot3.1之后才添加的，用来代替配置文件中的Compnent—scan来开启组件扫描，可自动发现和装配Bean，即自动扫描包路径下的@Compnent进行Bean实例化到context

### **11：SpringBoot启动流程**

1. 初始化配置，通过ClassLoader，LoderFactories读取classpath下所有的Sping.factories配置文件，创建一些初始化配置对象，通知监听者应用程序启动开始，创建环境对象environment，用于读取环境配置，例如：application.yml
2. 创建应用程序上下文，CreateApplicationContext，创建beam工厂对象
3. 配置工厂对象，包括上下文ClassLoader ，对象发布处理器，BeanFactoryPostProcessor（发布处理器）
4. 注册并实例化BeanFactoryPostProcessor，并且调用这些处理器，对包扫描解析
5. 注册并实例化BeanPostProcssor
6. 初始化一些与上下文特别有关系的bean对象，默认的Tomcat服务器创建就是在此方法完成（onRefresh），此处定义特别的Bean创建，一般是服务器有关或者个性化的对象
7. 实例化所有Bean工厂缓存的Bean对象
8. 发布通知，通知上下文刷新，启动Tomcat服务器
9. 通知监听者，启动程序完成

### **12：SpringBoot读取配置文件的方式**

1. 使用@Value注解，这个注解默认读取的是Application文件
2. 使用Environment读取文件，只需要在类中注入Enviroment，就能读到相关配置
3. 使用@ConfigurationProperties注解，当项目变量比较多的时候用以上两种比较繁琐，这个时候通常就会用ConfigurationProperties，将Properties属性和Bean关联在一起，只需要注解就可以读取到配置文件属性记得要用perfix来指定读取前缀

### **13：自定义Spirng Starter**

1. 创建一个Spring Boot项目，在POM文件导入相关依赖
2. 删除启动类，resources下的文件，test文件
3. 编写Properties属性，用于读取属性
4. 创建配置类
5. 创建自动配置类
6. 在resources文件下新建一个META-INF文件，并在下面创建Spring.factories文件，将配置类进行注册
7. 执行mav clean install将项目打成Jar包即可





# **四：Mysql&Mybatis**

### **1：什么是索引**

索引的本质是帮助sql高效获取数据的数据结构，Mysql主要应用的索引数据结构为B+tree

### **2、Mysql的数据结构？为什么用这种结构？提高磁盘IO效率**

Mysql的数据结构为B+tree

由于数据存储与物理磁盘我们要尽量减少IO的次数，才能有效提高查询效率。

1. B+tree的非叶子节点存放的都是主键，主键占用空间少，每个节点能存放的主键就能够，能有效的降低树高，从而减少IO次数
2. 磁盘预读，预读的长度一般为page的倍数



### **3、数据IO的查找流程？**

1：对于聚集索引（主键索引）来说，也就是通过主键查询，一次查询就能查询到具体的行数据信息



2：对于非聚集索引（唯一索引，普通索引，全文索引）来说

​             如果需要查询的数据列在索引中，如A+B联合索引，根据A去查询B，则通过一次查询就能直接拿到索引上的数据，也就覆盖索引的现象

​             如果需要查询的数据列不在索引中，则需要去普通索引数中进行第一次查询得到行数据的主键值，然后通过主键值去主键索引库中第二次搜索得到真实数据，这种需要二次查询的现象叫回表查询





### **4、B+tree和Btree组成？异同**

B+tree和Btree都是由叶子节点和非叶子节点组成的

异同：

1. B+tree是Btree的变体
2. B+tree在Btree的基础上增加了叶子结点间的顺时针访问指针,加快范围查询的效率
3. B+tree每个结点的指针上限为2d，Btree每个结点的指针上限为2d+1
4. B+tree非叶子结点只储存索引值，叶子结点储存真实数据。而Btree所有结点上都储存数据



### **5、InnoDB和Mysiam的区别？**

这两种引擎B+tree的叶子结点和非叶子结点分别存储的什么？

区别：Mysiam的索引和数据分两个文件夹进行储存，MYI文件储存索引，MYD文件储存数据，所以Mysiam的B+数只储存了索引key值地址，而真正的数据是储存到MYD文件的。

叶子结点储存数据地址值，非叶子结点储存索引值

​           InnoDB的索引和数据都储存在一个文件，ibd文件，所以能知道InnoDB储存引擎中的B+数既储存了索引又储存了数据

叶子结点储存真实数据，非叶子结点储存索引值

InnoDB 支持行锁  ，Mysiam只支持表锁

InnoDB 支持事务  ，Mysiam不支持

### **6、Mysql索引有哪些类型？**

什么场景使用哪种索引？

按类型分有聚集索引（主键索引）和非聚集索引

主键索引：是特殊的唯一索引，一个表只能有一个主键键，不允许由空值，

普通索引：普通索引是最基本的索引，他没有任何限制，值可以为空

唯一索引：索引列的值可以为空，但是必须唯一，如果是组合索引，则列值的组合必须唯一

组合索引：是在多个字段上创建索引，只有在查询条件中使用了创建索引的第一个字段，索引才会被使用，使用组合索引时要遵循最左前缀集合

全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。



### **7、如何进行Mysql优化？**

（sql优化层面和服务器优化层面）

sql优化：

1：不要使用select * 去查询

2：规范大小写，sql是有缓存，避免每次都要解析

3：使用exsits代替in，更加高效

4：mysql sql解析的时候时从右到左（从下到上）原则，基于这个原则from后面能过滤掉更多数据的基础表放后面，where后面能过滤掉跟多数据的查询条件放后面

5：查询条件中用相同类型去查，避免数值列用字符串查询条件，因为会导致索引失效

6：合理使用索引：1：为合适的列添加索引           

​                               2：尽量建立联合索引，也节省空间成本             

​                               3：尽量建立覆盖索引         

​                               4：要去避免会使索引失效的操作，比如：索引列有Null。

​                                                                                              ：使用负向查询not，not in，not like

​                                                                                              ：like将%放左边

​                                                                                              ：建立联合索引要遵循最左匹配机制





7：explain命令进行慢查询排查，这是查询之后的具体信息：运维有慢查询的监控平台

​                        1：id：select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的循序，当id相同，执行顺序从上到下。id值越大优先级越高，越先执行

​                        2：select_type：查询类型。有simple，primary，subquery（子查询），derived，union，union result 

​                        3：table：正在访问那个表

​                        4：partitions：匹配的分区

​                        5：type：访问的类型，效率从快到慢：        使用null>system>const>eq_ref>ref>ref_or_null>index_merge>range>index>ALL

​                        6：possible_keys：显示可能应用在该表中的索引

​                        7：key：实际使用到的索引，如果时null，则没有索引

​                        8：key_len：表示索引中使用的字节数，可以通过该列计算查询中使用的索引长度

​                        9：ref：显示索引的那一列被使用了

​                        10：rows：根据表统计信息及索引选取情况，大致估算出找到所需记录所读取的行数，这个值越小越好

​                        11：filtered：查询的表行占表的百分比

​                        12：extra：包含不适合在其他列中显示十分重要的额外信息

服务器优化：

1：读写分离：主节点写，从节点读

2：分库：根据业务或者其他维度把数据存放到不同的数据库

3：分表：1：水平分表：字段都一样，分多张表存放不同时间范围或不同维度的数据，比如：实时数据，历史数据

​                2：垂直分表：将不同字段放在多张表，使用外键关联

​                 常用分库分表工具Mycat





### **8、Sql调优从何入手（措施）**

调优无非就两点，减少响应时间（减少数据库每个增删改查操作的执行时间）

​                             提高吞吐量（提高数据库单位时间内能够执行操作的数量）

从三个维度进行优化：

客户端优化：sql语句：通常业务中最常见的就是sql查询速度慢的问题，这个需要我们用expiain去排查慢查询问题

服务端优化：Mysql配置：mysql配置文件中支持很多配置选项，同时很多重要配置也帮助我们设置了默认值，通常时无需修改就可以正常部署，但是这也代表这默认配置并不是适合当前项目及系统的最佳配置。

架构层优化：表结构和存储引擎：我们都知道数据库表结构设计对于业务来说时非常重要的，良好的表结构设计时高性能的基石，同时Mysql也支持多种储存引擎，每种存储引擎都有自己的特点，针对不同的的表使用不同存储引擎

​                      应用层方案：相对于来说把所有压力都给到数据库，其实我们在应用层还有很多操作可以让数据库减轻压力，也是一种对于数据库的调优，比如缓存，限流，异步

​                      读写分离：通过主库写，从库读，不但解决数据库事务隔离级别中的读写锁的竞争冲突，还有一有效分摊了数据库压力，不过也会带来数据延迟问题

​                       分库分表：按照业务去拆分数据库为垂直分库，把单张表按照一定规则拆分到不同表中为水平分表，这样拆分操作可以有效减少单个数据库结点的访问压力，已经单个表数据的存储压力

​                       高可用方案：如果数据库意外宕机了，或者某个结点搞了，无法提供访问，就会导致吞吐量下降，甚至无法响应，所有选择好的高可用方案也是提高数据线性能的基础



### **9、合理使用索引？索引失效**

如何合理使用索引：

1. 为合适的列添加索引（主键，唯一，组合）
2. 尽量建立联合索引，能节省空间成本
3. 尽量使用覆盖索引

索引失效：

1. 索引列有null值不走索引
2. 使用is not 或 is not null不走索引
3. 各种负向查询not，not in，not like，<>,!=,!>,!<不会使用索引
4. like的%放左边不走索引
5. 查询条件的属性类型做了隐式转换
6. 使用in或union代替or，or两侧有非索引列就不会走索引
7. 保持索引列感觉，索引列上有函数转换，运算就会失效
8. 联合索引要遵循最左匹配原则
9. 使用比较运算或between会使联合索引从使用比较运算的下个个索引处断开



### **10、排查慢查询？信息项？**

explain命令进行sql慢查询

1. id：select的查询序列号，表示查询中执行select子句或操作表的顺序，id相同顺序从上到下，不同则值越大优先级越高
2. select_type：查询类型，simple，primary，subqurey，derived，union，union result
3. table：正在访问那个表
4. prititions：匹配的分区
5. type：访问的类型：效率从快到慢：null>sysetm>const>eq_ref>ref>ref_or_null>index_merge>range>index>ALL
6. possible_keys：显示可能应用在这张表的索引，一个或多个
7. key：实际用到的索引
8. key_len：表示索引中使用的字节数，可以通过该列计算出查询中使用索引的长度
9. ref：显示索引那一列被使用了，那些列或常量被用于查找索引上的值
10. rows：根据表统计信息及索引选用情况，大致估算出找到所需记录读取的行数，这个数越小越好
11. filtered：查询的表占表的百分比
12. Extra：包含不适合在其他列中显示但十分重要的额外信息



### **11、事务特性隔离级别？**

Mysql事务隔离级别有哪几种？

分别会产生什么问题？

Mysql默认隔离级别是什么？Oracle呢？

mysql的默认隔离界别是repeatable read，oracle默认隔离级别是read commintted

事务的特性是ACID

原子性：要么全部成功，要么全部失败

一致性：执行前后数据库信息必须保证一致

隔离性：一个事务在提交之前，其他事务是不可见的

持久性：事务完成后，会永久的保存到数据库当中，即使系统崩溃，执行的结果也不会丢失

隔离级别及问题：

| 事务隔离级别                 | 脏读   | 不可重复读 | 幻读   |
| ---------------------- | ---- | ----- | ---- |
| 读未提交（read-uncommitted） | 是    | 是     | 是    |
| 不可重复读（read-committed）  | 否    | 是     | 是    |
| 可重复读（repeatable-read）  | 否    | 否     | 是    |
| 串行化（serializable）      | 否    | 否     | 否    |

脏读：一个事务可以读到另一个事务尚未提交的信息，不符合事务的隔离性

不可重复读：同一个事务中针对同一行记录两次读出来的结果不一样，原因是第二次读到了其他事务修改的数据

幻读：同一个事务针对同一范围的数据两次读出来的结果不一样，原因是第二次读到了其他事务新增的数据

更新丢失：当多个事务选择同一行操作，并且都是基于最初选定的值，由于事务的隔离性，就会发生更新覆盖问题



### **12、行锁表锁，悲观锁乐观锁**

行锁：InnoDB默认采用行锁，加锁可以保证事务的一致性。缺点是开销大，加锁慢，会出现死锁的情况，优点是锁的颗粒小，发生锁冲突的概率自然也低，处理并发的能力很强。

表锁：InnoDB在未使用索引字段查询时自动升级为表锁，mysql会根据自身计划考虑是否使用索引，如果mysql认为全表扫描效率更高，它就不会使用索引，这种情况下InnoDB将会使用表锁，而不是行锁，第一种情况就是全表更新，事务需要更新大量数据，而表又大，若使用行锁效率肯定降低，还有可能导致其他事务长时间等待和锁冲突，第二种情况就是多表查询，事务涉及到多个表，比较复杂的关联查询，很有可能会引起死锁，造成大量事务回滚，这种情况使用表锁，能一次性锁定事务涉及的表，从而避免死锁，减少数据库因事务回滚带来的开销。缺点，锁颗粒大，发生锁冲突概率搞，并发处理能力低。优点，开销小，加锁快，无死锁

悲观锁：悲观的认为本次事务一定会有别的事务干扰，操作之前必须加锁，在实现的适合要注意由于mysql锁是建立在索引上的，所以查询条件必须用主键索引，否则会造成全表扫描

乐观锁：乐观地认为本次事务操作数据不会有别的事物干扰，操作之前不进行加锁，只会预留一个版本号，真正修改数据的时候在进行比对



### **13、vachar和char的区别？**

区别一： 变长和定长

vachar表示边长，即长度可变。char表示定长，即长度不可变。

区别二：存储容量不同

vachar最多存放65532个字符，最大有效长度由最大行大小和字符集确定。整体最大长度为65332字节

char最多能存放255个字符，和编码无关



### **14、什么是内连接(inner join)、外连接（left join）？**

内连接可以理解为两张表的交集，

外连接分为左外连接和右外连接，左外连接相当于查询左边那张表所有的数据和交集部分的数据

​                                                      右外连接相当于查询右边那张表所有的数据和交集不发的数据

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCEdb035b68e83813ec759880250b5393ef/4755)





### **15、Mybatis底层的原理？一级缓存和二级缓存是什么？**

在了解底层之前，可以先看看Mybatis执行流程：

（1）读取MyBatis的配置文件。mybatis-config.xml为MyBatis的全局配置文件，用于配置数据库连接信息。

（2）加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。

（3）构造会话工厂。通过MyBatis的环境配置信息构建会话工厂SqlSessionFactory。

（4）创建会话对象。由会话工厂创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。

**（5）Executor执行器。MyBatis底层定义了一个Executor接口来操作数据库，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。**

（6）MappedStatement对象。在Executor接口的执行方法中有一个MappedStatement类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。

（7）输入参数映射。输入参数类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程。

（8）输出结果映射。输出结果类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于JDBC对结果集的解析过程。

在执行流程里面最重要的就是两个对象就是configuration和transaction

configuration是mybatis的配置对象，是用来储存xml配置文件中解析到的所有数据，由三个非常要中的属性

environment：id确定连接的数据库，dataSource则是数据源

mapperRegistry：构建了所有Dao接口的Class对象，用来生成代理对象，在这里就可以知道底层就是动态代理

mappedStatements：储存方法名和sql语句

缓存：

一级缓存是mybatis自带的HashMap本地缓存，缓存的是sql语句。作用范围为session域中，当刷新或者关闭时session中所有缓存

二级缓存是全局缓存，缓存的是结果对象。作用域超出session范围之外，可以被所有sqlSession共享



### **16、mybatis #{}和${}的区别？**

\#{}能防止sql注入，${}无法防止sql注入

\#{}表示的是一个占位符符号，而${}是将传入的数据直接显示生成到sql里面的

在JDBC能使用占位符的地方用#{}，在不支持占位符的地方就只能用${}，典型情况就是动态参数

#{}会进行sql预编译





### **17、存储过程存储函数触发器，创建语法**

储存过程和储存函数都是一组sql语句的集合，这些语句集合被当作一个整体存入数据库中

存储过程语法：create procedure 储存过程名（参数列表） sql语句

存储函数语法：create function 函数名（）  return返回类型     sql语句

触发器：触发器是与表有关的数据库对象，在满足定义条件的时候触发，并执行触发器中定义的语句集合。触发器这种特性可以协助应用在数据库端确保数据的完整性

语法：create trigger 触发器名 before/after 触发事件 on 表名 for each row    begin 执行语句 end



### **18、union和unionAll有什么区别？**

在将两个select语句结果最为一个整体展现出来，union会自动压缩多个结果集合中的重复结果，而union All 则会将所有的结果全部展示出来，不管是不是重复



### **19、创建表、删除表、更新表字段语句？**

创建：create table 表名（里面设置字段名和字段条件）

删除：drop table 表名

更新： 1：增加表字段：Alter table 表名 add column 字段名 类型

​            2：删除表字段：Alter table 表名 drop column 字段名



### **20、mysql左外连接语句的写法？**

select 查询字段 from 表名1  left join 表名2 on 查询条件



### **21、听过InnoDB的Mvcc技术吗？说下是什么？**

mvcc是多版本并发控制器，目的是为了提交数据库在高并发场景下的性能

是Repeatable_read事务隔离级别的底层，保证AB客户端所示的数据相互隔离，互相更新不可见

Mvcc最大的优势，读不加锁，读写不冲突，在读多写少的情况下极大增加了系统的并发性

Mvcc的实现通过两个最重要的字段进行连接，DB_TRX_ID 和 DB_ROLL_PT,在多个事务进行并行操作某行数据的时候，不同事务对该行数据的update会产生多个版本，数据库通过ID来标记版本，然后用PT回滚指针将这些版本以先后顺序连成一条Undo log链

特点：每行数据都存在一个版本，每次数据更新时都会更新该版本

​           修改时copy出当前版本随意修改，各个事件无干扰

​           保存时比较版本号，如果成功则覆盖原记录，如果失败则放弃copy（rollback）



### **22、Java实现动态代理有哪些方式？区别是什么？**

JDK动态代理和CGLIB动态代理

区别：

1：JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用invokeHandler来处理。CGLIB动态代理是利用字节码处理框架ASM，将代理对象类的Class文件加载进来，通过修改其字节码生成子类来处理。所有JDK创建代理对象效率高，但执行效率低。CGLIB创建效率低，但执行效率高。

2：JDK动态代理机制是委托机制，动态实现接口类，在动态生成的实现类里面委托Handler取调用原始实现类方法。CGLIB则使用的继承机制，被代理类和代理机制是继承关系，所以代理类是可以赋值给被代理类的，如果被代理类有接口，也可以赋值给接口。

### mysql如何避免死锁

已一定的顺序访问表和行 

如果业务允许的话将大事物拆分成小事务

降低事务级别

尽量一次性将你需要的事务锁定

# **五：多线程**

### **1、创建线程的方式有哪些？相比继承Thread类，实现Runable接口的好处是什么？**

创建方式

1. 继承Thread类
2. 实现Runable接口
3. 实现带返回值的Callable接口
4. 使用线程池创建线程

对比继承Thread类，实现Runable接口的好处

1. java是单继承有局限性。但是可以多实现，实现Runable接口之后还可以实现别的接口，代码健壮性更高
2. Runable接口可以说是多线程的底层，主要就是用来封装任务，Thread类也是通过他来实现的
3. 使用Runable接口可以很方便对共享资源进行传入



### **2、线程的状态有哪些？**

1：新建（new）新建一个线程，但是还没有调用start方法

2：可运行（ranable）调用了start方法，但是还没有获得CPU的执行权，处于等待获取执行权的状态

3：运行（running）已经获得CUP的执行权，处于正常执行状态

4：阻塞（blocked）这种状态是指处于运行状态时因为某种原因放弃了使用CPU的执行权，暂时暂停了运行需要后续某些操作才可以继续进入运行状态，一般阻塞分为三种情况：

​               1）等待阻塞：运行的线程执行wait方法，JVM会把该线程放入等待队列中，当别的线程执行了notify或者notifyAll后可以对其进行唤醒进入锁池，让该线程处于抢锁状态，从而有机会从新进入可运行状态

​               2）同步阻塞：运行的线程在获取对象的同步锁时，若该线程被别的线程占用，则JVM会把该线程放入锁池中。

​               3）其他阻塞：运行的线程执行了sleep方法或join方法，或者发出I/O请求，JVM会把该线程设置为阻塞状态，当Sleep超时，join等待线程终结，IO处理完毕，线程重新进入可执行状态



### **3、run()和start()方法有哪些区别？**

run只是一个封装方法的普通任务，调用run不会开启线程，start会开启线程，底层会调用run方法



### **4、实现线程间通讯的方法有哪些？**

1：使用volatile关键字：实现线程间的相互通讯是使用共享内存的思想，大致意思就是多个线程监听同一个变量，这个变量发生变化的时候，线程能够感知并执行相应的业务，最简单的实现方式

2：使用Object类中的wait方法和notify方法，必须配合synchronized使用，wait会释放锁，notify不会释放锁

3：使用JUT工具类中的CountDownlatch，基于AQS框架，当相遇维护了一个线程间共享变量State

4：管道输入/输入流，用于线程间的数据传输，传输的媒介作为管道



### **5、wait、notify、notifyAll分别的作用是什么？可以用在同步代码块之外吗？为什么？**

作用：

wait：让运行的线程进行等待

notify：在等待线程中唤醒其中一个线程，具有随机性

notifyAll：在等待线程中唤醒全部线程

不可以在同步代码块之外，为什么？：

1：在运行层面来说，如果写在别的位置会报非法监视异常，这里的监视器是锁对象

2：从原理层面来说，这三个方法是用于线程间通讯的，而控制线程通讯的主体对象是锁对象，使用这三个方法控制线程的时候必须先通过Synchoronized获取并指定锁对象

​      锁对象维护着一个等待队列List，通过锁对象调用wait方法则会让线程进入这个等待队列List，调用notifyAll方法则会从队列List中取出这个线程执行执行



### **6、Sleep和Wait的区别？**

1：调用对象不同，sleep，jonin，yield，interrupted等都是属于Thread类的静态方法

​                               wait，notify，notifyAll扽都是object方法，任何对象都可以作为锁对象进行调用

2：是否释放锁：sleep不会释放锁，只是让出了CPU的执行权，但wait会释放锁，而且会加入到等待队列中

3：sleep可以在任何地方使用，wait只能在Synchronized同步方法或者同步块中使用

4：重新运行机制：sleep过了指定的睡眠时间就会从阻塞状态回到可运行状态，wait方法需要手动调用notify或notifyAll方法进行手动唤醒，进入锁池等待



### **7、什么是线程安全问题？什么情况下会产生？如何解决？**

什么是线程安全：多线程操作共享资源时，导致共享资源出现错乱，线程安全问题都是由全局变量及静态变量引起的

什么情况下会产生：多个线程访问同一资源时，且对多个线程同时执行写操作，就会产生线程安全问题，例如电影院要通过三个窗口卖出一共100张票

如何解决：

线程同步：对一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程这时是处于等待状态。在此java中提供了同步机制（Synchronized）来解决，有三种方式完成同步操作，达成线程同步机制：

​                1）同步代码块，Synchronized关键字可以用于方法中的某个区域，表示只对这个区块的资源实现互斥访问

​                2）同步方法，使用Synchronized修饰的方法叫同步方法，保证一个线程在执行该方法的时候，其他线程只能在方法外等待

​                3）锁机制，Lock锁提供了比Sychronized代码块和Sychronized方法更广泛的锁定操作，这两个有的功能Lock都有。Lock锁也叫同步锁。

当然在解决线程安全问题的时候也要注意会不会死锁



### **8、什么是死锁？如何防止产生死锁？**

死锁：在多线程程序中，使用了多吧锁，造成线程之间的相互等待，程序不往下走了，就是死锁

防止死锁：

1：加锁顺序，线程按照一定的顺序加锁

2：加锁时限，线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁

3：死锁检测：当一个线程获得了锁，会在线程和锁相关的数据结构中（如map）记录下来，除此之外每当有线程请求锁，也需要记录在这个数据结构中，当一个线程请求失败时，这个线程可以遍历锁的关系图是否有死锁发生，如果发生了可以给出相对于的提供方案，如释放所有的锁，或给这些线程设置优先级，让一个或几个线程回退



### **9、Synchronized关键字的底层原理是什么?**

首先要直到java对象分为对象头，对象实例数据等，其中对象头的mard word部分记录对象的锁信息。

底层原理是通过monitor对象来完成的，monitor会内置在每一个对象中，任何一个对象都又一个monitor与之关联，Sychronized在JVM里面实现就是基于进入和推出monitor，底层是通过对MonitorEnter和monitorExit指令来实现。可以把monitor理解成一个同步工具



1.6的优化包括：轻量级锁、锁自旋、自适应锁自旋（就是不断去尝试获取锁，不会轻易进行线程状态的切换）、锁粒度粗化



### **10、Synchronized可以用在哪些地方？分别的锁对象是什么？**

Sychronized是java中的一个关键字，他的修饰对象分以下几种

1：修饰一个代码块，被修饰的方法称为同步语句块u，其作用范围是整个方法，作用的对象是调用这个方法的对象，锁对象是括号中的对象

2：修饰一个方法，被修饰的方法称为同步方法，其作用范围是整个方法，作用对象是调用这个方法的的所有对象，锁对象是为当前对象this

3：修饰一个静态方法，其作用范围是整个静态方法，作用的对象是这个类的所有对象，锁对象为Class字节码文件

4：修饰一个类，其作用范围是Sychronized后面括号括起来的部分，作用对象是这个类的所有对象



### **11、JUC下Lock锁和Synchronized的异同？**

1：Lock是JUC包下封装好的锁，是类的概念。Sychronized是一个虚拟机层面的关键字

2：Lock显示的加锁和隐锁，且解锁要在finally代码块中，否则可能会死锁。而Sychronized为隐式的上锁和解锁

3：Lock锁提供了尝试获取锁和设置获取锁的时间的机制，可返回取锁状态，当获取不到锁的时候也可以选择放弃锁。Sychronized无法判断返回取锁状态，取锁不成功直接阻塞，没有Lock灵活

4：Lock锁阻塞可以被打断，而Sychronized阻塞不可被打断

5：Lock可实现可重入，可公平锁，而Sychronized是可重入，非公平锁

6：Lock可以很灵活的根据线程角色类型去创建Condition监视器对象，调用await，signal，signalAll进行线程通讯调度。而Sychronized使用Object对象作为监视器对象，调用的是wait，notify，notifyAll去进行线程通讯调度。

7：Lock提供了更丰富的锁分类，如读锁，写锁，可以更颗粒化的关注线程安全





### **12、Synchronized在JDK1.6做了什么优化？**

自适应的CAS自旋，锁消除，锁粗化，偏向锁，轻量级锁



### **13、Synchronized是公平锁还是非公平锁？获取不到锁时会阻塞吗？**

非公平锁，会，因为Sychronized无法判断返回的取锁状态。



### **14、同步代码块中执行完wait/notify/notifyAll后会立马释放锁吗？**

不会，必须要等待所在的同步代码块执行玩才会释放锁。



### **15、Lock锁有哪些实现？分别的特点是什么？**

公平锁与非公平锁

特点：公平锁多了一步hasQueuPredecessors（）的判断，限制了当前线程如果是等待线程的头结点才回去获取锁保证了公平性，而非公平锁则没有这个限制，可以直接去插队尝试获取锁



### **16、JUC下Lock的监视器对象是哪个类？与Synchronized的监视器有什么异同？**

Lock的监视器是Condition接口，Sychronized是monitor

异同：

前置条件：Condition调用Lock获取锁或是调用newCondition获取Condition对象，monitor是直接获取对象的锁

调用方法：Condition是 await，signal，signalAll。monitor是wait，notify，notifyAll

等待队列个数：Condition支持多个，monitor只支持一个

当前线程释放锁并进入等待状态不响应中断：Condition支持，monitor不支持



### **17、什么是线程可重入？Synchronized具备吗？Lock呢？**

可重入：在一个线程某个方法获取锁后，进入该线程的其他方法不需要重新取锁。都具备



### **18、什么是AQS？**

AQS是用于构建锁和同步容器的队列同步器，它是整个JUC体系的核心，如ReentrantLock，ReentrantReadWriteLock，CountDownLatch，Semaphore都是基于它实现的，它解决了同步容器设计的大量细节问题，他的核心构成部分为：一个先进先																																					出的FIFO队列储存排队等待锁的线程，用一个Volatile修饰的Int类型的State同步状态来记录当前线程是否有锁，0表示没有线程获得锁，1表示有，上锁state就加1，释放锁就对应-1，有重入锁这个值就大于1Rabbit的集群有哪几种，然后需要逐级去释放。



### **19、什么是CAS？什么是CAS的ABA问题？如何解决？**

CAS其实就是乐观锁的一种实现方式，而悲观锁比较典型的就是java中的Synchronied

CAS全称Compare and swap——比较并替换 保证了数据的原子性，它是并发条件下修改数据的一种机制，包含了三个操作，1）需要修改数据的内存地址记录为（V） 

​                             2）记录这个数据当前的值记录为（A）

​                             3）需要修改时查看下地址V的值，如仍为A，则用B替换他，若地址V下的值不为A，表示在修改的过程中其他线程对数据进行了操作，则不更新变量的值，而是从步骤2开始执行，这一步也称为自选。                      CAS贯穿于整个AQS体系，是AQS实现的基础。

优点：CAS是乐观锁，不需要加锁就能进行原子操作

缺点：CAS机制只能用在对于某一个变量进行原子操作，无法用来保证多个变量或语句的原子性

​           如果在修改数据的过程中经常与其他线程修改冲突，将导致多次重试

​           有可能产生ABA问题

ABA问题：假设小明在提款机提取了50元，因为提款机的原因有两个线程同时把余额100改成50

线程1：获取当前值100，期望更新到50

线程2：获取当时值100，期望更新到50

线程1成功执行，线程2因为某种原因阻塞，这时某人给小明汇款了50

线程3：获取当前值50，期望更新到100

这时线程3执行成功，余额变成100，这时线程2从阻塞中恢复了，执行之后又将值改为了50

此时可以看到实际余额应为100，但实际上变成了50，这就是ABA问题

解决：在变量上加上版本号，每次变量更新的时候变量的版本号+1，即A-B-A就变成了1A-2B-3A



### **20、你了解JUC下的哪些工具类，分别有什么作用？（CountdownLatch、Cyclicbarrier、Semaphore）**

1：CountDownLatch：通常用来控制某个线程等待，让某组线程执行完才能执行调用await的线程

具有计数器功能，构造方式初始化数量，通常调用await方式控制某个线程等待，其他线程执行完后会CountDown一次进行减1，直到CountDown为0才会执行阻塞线程

需要注意：CountDownLatch计数的次数一定要与构造器传入的数字一样，比如构造器传入的是3，则CountDown一定要执行3次，否则await的线程将一直阻塞

2：CyclicBrarier：类似CountDownLatch，区别是CountDown之后才会执行自己的任务。而CyclicBrarrier会在所有线程任务结束之后，才会执行后续任务。

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE65d3c9a2e6e7ad7aa5dcd0767611d9c5/5904)

3：Samephore：常用于控制某一贡献资源访问的访问线程的最大数。也是一种计数器，用来保护一个或多个共享资源的访问，如果线程要访问一个资源就必须先获取信号量，如果信号量内部计数器大于0，信号量-1，然后允许共享这个资源，如果信号量的计数器等于0，信号量就会把线程置入休眠状态直到计数器大于0，当信号量用完时，必须释放

### **21、说下volatile关键字，有什么作用？原理是什么？**

volatile是java的关键字，是一个类型变量修饰符，被volatile修饰的变量有以下几个特性

1：可见性，保证了不同线程对这个变量进行操作的可见性，即一个线程修改了某个变量的值，这个新值对其他线程来说是立即可见的。

​              如何实现的：用volatile形容的变量，线程写入本地内存的同时会将数据立即刷新到主内存中。其他线程读取该变量的时，发现被volatile修饰，会将本地变量值置为无效，直接从主内存中读取

2：有序性，禁止进行指令重新排序。为了提高执行效率，在不影响最终执行结果的前提下，代码在编译成字节码的时候有可能进行指令重新排序，这个在单线程情况下是没有问题的，但是在多线程的情况下会出现问题，volatile则可以避免这个问题

3：不保证原子性，volatile只能保证单词读写的原子性，例如i++这种操作不能保证原子性，关于volatile原子性可以理解为把对volatile变量的单个读写，看成是使用同一个锁对这些单个读写操作做了同步



### **22、说下ThreadLocal，有什么作用？有哪些主要方法，实现原理是什么？为什么会有内存泄漏问题？如何解决？**

作用：ThreadLocal是JDK包提供的，它提供本地线程变量，如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个副本，在实际多线程的操作中，操作的是自己本地内存中的变量，从而规避了线程安全问题

主要方法：get，set，remove

实现原理：每个线程都有属于一个自己的ThreadLocalMap，可以通过Thread获得，这个map储存着以ThreadLocal对象为Key，设置的值为value的键值对，调用get，set，remove方法都是操作这个map

内存泄漏：

ThreadLocalMap使用ThreadLocal的弱引用作为key，如果ThreadLocal没有外部强引用他，那么当系统GC的时候，这个ThreadLocal势必会被回收，这样依赖ThreadLocalMap就会出现key为null的Entry。就没有办法访问这个key为null的Entry的value。如果当前线程在迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：ThreadLocalREF —ThreadLocal—ThreadLocalMap—Entry—Value，永远无法回收，造成内存泄漏

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCEe836810e9206e2afbd75578852eb3773/6074)

解决方法：在使用完ThreadLocal后执行remove操作，避免出现内存溢出的情况。





### **23、说下线程池的几大核心参数？分别有什么作用？有几种默认的线程池？他们的7个核心参数为什么要那么设置？**

核心参数：

1：corePoolSize，核心线程数大小，当线程数

2：MaximunPoolSize，最大线程数，当前线程数>=corePoolSize的时候，会把任务放入workQueue队列中

3：keepAliveTime，保存存活时间，当前线程数大于corePoolSize的空闲线程能保持的最大时间

4：unit，keepAliveTime的时间单位

5：workQueue，保存任务的阻塞队列

6：ThreadFactory，创建线程工厂

7：handle，当前最大线程数量后执行的拒绝策略





**默认线程池：**

**newSingleTreadExecutor：单线程的线程池，**它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来代替它，特点：能够确保依照任务在队列中顺序来串行执行。

​			创建细节：new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue()));

**newFixedThreadPool：固定大小的线程池**，每次提交一个任务就创建一个线程，直到线程达到线程池的最大数量，这时线程规模将不会变化。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池就会补充

​	                创建细节：new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());

**newCachedThreadPool：可缓存的线程池**，如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（设置空闲线程最大保持时间的时间数）的线程，当任务数增加时，此线程又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小

​                       创建细节：new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue());



### **24、单例模式写法有哪几种？（懒汉和饿汉式）那么懒汉式中保证线程安全的写法是什么？为什么要用双重检查模式？**

写法：

1：懒汉式，顾名思义用到的时候才去创建，如需要线程安全可加上Sychronized关键字

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCEcd0af9b58f5724052e206a8487efb336/6292)

2：饿汉式，实例在初始化的时候就创建按好了，没有线程安全问题，但浪费了内存空间

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE0b8fbdf7dc4bfdb0cb13a612a5235584/6294)

3：双检锁

双检锁又叫双重校验锁，综合了懒汉式和饿汉式两者的优缺点整合而成。特点在Sychronized关键字内外部都加了if判断，这样既保证了线程安全，又比直接上锁提高了执行效率，还节省了内存空间

所谓双重检查机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后先检查实例是否存在，如果不存在才进入下面的同步块，这时第一次检查。进入同步块后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间

这种方式既可以实现线程安全的创建实例，又不会对性能造成太大的影响，它只在第一次创建实例的时候同步，以后就不需要同步了，从而加快允许速度

**注意volatile修饰变量的使用。**volatile关键字可能会屏蔽虚拟机中一些必要的代码优化，所以运行效率并不高，因此一般建议没有特别的需要，不要使用。也就是说虽然双检索机制用来实现线程安全的单例，但并不建议大量采用，根据情况而定

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCEae76a95a3c3a1d8f9df31b8d35a0efe4/6316)

4：静态内部类

5：枚举



hash结构用于存储动态点赞数据

set用于存储喜欢/不喜欢数据，求交并集

zset 排行榜



# **六：Redis & 多级缓存**  

### **1、Redis是一个什么样的数据库？读写速度怎么样？**

Redis本质上是一个Key—value类型的数据库，整个数据库加载都在内存当中操作，定期通过异步操作把数据库中的数据flush到硬盘中保存

因为是纯内存操作，redis的性能十分出色，每秒可以处理超过10W次读写操作，是已知性能最快的Key—value类型的数据库。



### **2、Redis有哪些数据类型，分别的特点？在你们项目中常见的应用场景有哪些？请列举**

1：String类型，最常用的一种数据类型，普通的key—value储存都归于此类，其中value既可以是数字也可以是字符串，使用场景：常规的key value缓存应用，常规计数：粉丝数

2：Hash，是一个键值对集合，是一个String类型的field和value的映射表，Hash特别适合储存对象，并且可以像数据库中的update一个属性一样，只修改某一项属性值

3：Set，是一个无序的天然去重集合，即key—set，此外还提供了交集，并集等一系列直接操作集合的方法，对于共同好友，共同关注什么功能的实现特别方便

4：List，有序可重复的集合，遵循FIFO原则，底层是依赖双向链表实现的，因此支持正向，反向双重查找。通过List我们可以很方便的获得类型最新回复这类功能的实现

5：SortedSet，类似与java中的TreeSet，是Set的可排序版本，此外还支持优先级，维护了一个score的参数来实现，适用于排行榜和带权重的消息队列



### **3、Redis的持久化机制是什么样的？**

​	**1）、什么是RDB？RDB的持久化机制（Save、bgSave）?**

**在指定的时间间隔将内存中的数据快照写入磁盘**，它恢复是将快照文件直接读到内存

机制：

**Save**：save命令会导致主进程执行RDB，这个过程中其他所有命令都会阻塞

**bgSave**：bgSave命令后会开启独立进程完成RDB，主进程可以继续处理用户请求，不受影响



​	**2）、触发RDB的时间点是什么？**

在四种情况下会运行：**执行save命令。执行bgsave命令，redis停机时，触发RDB条件时**

触发RDB条件则是自己在redis.conf文件里面进行配置   save m  n



​	**3）、RDB的优缺点分别有哪些？**

**优势**：适合大规模的数据恢复，对数据完整性和一致性要求不高

**缺点**：执行时间较长，且在一定间隔时间做一次备份，如果这时redis意外down掉的话，就会丢失最后一次快照后的所有修改，fork子进程，压缩，写出RDB文件都比较耗时



​	**4）、什么是AOF？分为几个阶段？(命令写入缓冲区、同步至日志文件、文件重写)**

**以日志的形式来记录每个操作，将redis所有操作但不包括读操作记录下来**

**阶段：命令写入缓冲区，同步至日志文件，文件重写**



​	**5）、AOF命令同步至日志文件分为哪几种？**

**Always：同步刷盘**

**everyesc：异步操作，每秒刷盘一次**

**no：系统控制时间**



​	**6）、AOF文件重写时间点？重写做了什么？**

**当AOF文件过大时，redis就会对该文件进行自动重写**

**自动重写：**重写时间点就是当AOF文件大小**超过指定的阈值，就会重写  64M**，这个可以在redis.conf里面去配置

**手动重写：**执行bgrewriteaof命令

做了什么：AOF会记录对同一个key的**多次操作，只会保留最后一次操作**

删除没有意义的命令



​	**7）、AOF的优缺点分别有哪些？**

**优点**：Always，同步持久化，每次操作都会立即记录到磁盘，性能差但是数据完整性高

​          everyesc，异步操作，每秒记录，性能适中，但一秒内宕机，这一秒的数据会丢失

​          no，性能最好，但可靠性较差，可能丢失大量数据

**相对于RDB的缺点**：AOF的文件要远大于RDB文件，恢复速度也慢于RDB

​                                 AOF运行效率要慢于RDB，每秒同步策略比较好，no效率和RDB相同







​	**8）、AOF和RDB同时开启会优先使用哪种进行数据恢复？**

**如果是数据不那么敏感**，可以从别的地方重写生成不回，可以关闭持久化

**如果是数据比较重要**，不想再从别的地方获取，且可以承受数分钟的数据丢失，比如缓存等，那么可以只是用RDB

**如果是做内存数据库**，**建议是RDB和AOF都打开，或定期执行bgsave命令**，RDB方式更适合做数据的备份，而AOF则是保证数据的不丢失，对了**4.0以后的redis对于持久化机制有优化，那就是RDB_AOF混合模式**



​	**9）、RDB-AOF混合模式是什么？优点有哪些？**

简单来说就是新的**AOF文件前半段是RDB格式的全量数据，后半段是AOF格式的增量数据**

**优点：**混合模式结合了RDB和AOF的优点，由于绝大部分都是RDB格式，加载速度快，同时结合AOF，增量数据是以AOF方式保存，数据更少的丢失

**缺点**：兼容性差，一旦开启了混合模式，在4.0之前的版本都不是识别该文件，同时由于前部分是RDB格式，阅读性差

要不我们打电话把！！！！！！



### **4、Redis主从结构能解决什么问题？**

提高并发，读写分离，主从同步保证数据的一致

### **5、Redis主从同步具体流程是什么？**

​	**1）、建立连接**

slave向master发送建立连接请求

master判断是否是第一次建立连接，如果是第一次会发送master数据库版本信息，然后master执行bgsave生成RDB文件发送给slave。这也就是全量同步，如果不是第一连接，则会做增量同步



​	**2）、数据同步（全量同步、增量同步）【runid运行ID、offset偏移量、复制积压缓冲区】**

​		1、**全量同步具体场景有哪些？流程？如何避免全量同步次数（全量同步非常耗时）**

**场景：**在第一次master ，slave连接时，或是slave阶段断开太久，repl_boklog中的offset已经被覆盖

**流程：**master判断是否是第一次建立连接，如果是第一次会发送master数据库版本信息，然后master执行bgsave生成RDB文件发送给slave，这时master也会有一个repl_baklog文件来记录RDB期间所有的命令发送给slave

**避免**：提高repl_baklog文件大小，发现slave宕机时尽快实现故障恢复



​		2、**增量同步具体场景有哪些？流程？**

**场景**：slave节点断开又恢复了，并且在repl_baklog中找到了offset

**流程**：slave会执行replicaof命令发送replid，offset给master，master判断replid是否一致，不是第一次，回复continue，去repl_baklog中获取offset数据，然后发送offset后的命令给slave

master知道slave与直接数据差异的原理：**repl_baklog**

这个文件是第一次建立主从的时候 master发送给slave的，这个文件是一个环形数组，也就是角标达到数组末尾后，会再次从0开始读写，这样头部数据就会覆盖，repl_baklog会记录redis处理过的日志和offset，包括master的offset和slave的offset。只要master的offset没有覆盖slave的offset就会继续增量同步，如果已经覆盖，那就会全量同步



​	**3）、命令传播**

### **6、如何优化主从同步效率？**

​	**1）、从尽量避免全量同步的方面入手（安全重启使runid不发生变化、调大复制积压缓冲区）**

安全重启，让runid不发生变化

提高repl_baklog文件大小



​	**2）、避免slave从结点太多造成复制风暴（使用树状拓补结构）**

现在一个master上的slave节点，如果实在太多slave，则可以采用主—从—从链式结构

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE6778b4f6eed49ced328136d34fb33792/6898)



### **7、Redis的故障恢复依靠什么机制？哨兵机制的主要工作范围、工作流程和作用？**

哨兵机制



直接用limit ？





工作范围：监控redis集群

作用：监控 故障转移 通知

工作流程：

sentinel基于心跳检测服务状态，每**一秒**向集群中每个实例发送ping命令

​                  主观下线：**某个sentinel节点发现某实例在规定时间内未响应**

​                  客观下线：**超过指定数量（quroum）的sentinel都认为该实例主观下线了**，则该实例为客观下线。quroum值最好为实例数量的一半

**1：**一旦发现master故障，sentinel则会在slave选择一个作为新的master，依据

​                    1：**判断slave节点与master节点断开的时间长短**，如果超过指定值（down after milliseconds * 10）则会排除该slave节点

​                    2：**判断该slave节点的slave_ping值**，越小优先级越高，如果时0则用不参与选举

​                    3：如果slave_ping值一样，则**判断slave的offset值**，越大说明数据越新，优先级越高

​                    4：最后判断**slave节点的运行ID大小**，越小优先级越高

**2：**选举成功后sentinel会给该slave节点发送slaveof no one命令让该节点变为master

**3：**sentinel会给其他所有slave节点发送slaveof （主节点的IP和端口） 让这个slave成为新master的从节点，开始从新的matser上同步数据

**4：**最后sentinel将故障节点标为slave，改故障节点恢复后会自动成为master的slave的节点

### **8、什么是缓存雪崩？缓存击穿？缓存穿透？分别如何解决？什么是缓存预热？**

**缓存雪崩：**

**某一个时刻大规模的key失效，**导致大量的请求到了数据库上面，导致数据库压力巨大，在高并发的情况下，可能瞬间就会导致数据库宕机。这时如果马上重启数据库，又会有新的流量把数据库打死

​                  **解决：事前：**

​                                   1**）均匀设置不同的过期时间，**避免相同的过期时间导致缓存雪崩，保证数据不会在同一时间大面积失效

​                                   **2）分级缓存**，第一级缓存失效的基础上，访问二级缓存，每一级缓存失效时间不同

​                                   **3）热点数据永不过期**，不设置过期时间或者是当发现要过期了，通过一个后台异步线程进行再次缓存

​                                   **4）主从+哨兵模式**，避免redis全面崩溃

​                             **事中：**

​                                   **1）互斥锁**，缓存失效后，通过互斥锁或队列来控制读数据和写缓存的数据进程，比如某个key只允许一个线程读数据和写缓存，其他线程等待。虽然防止了缓存雪崩，但是会让系统吞吐量下降

​                                   **2）熔断机制，限流降级**，当流量达到一定的阈值，直接返回“系统拥挤”等字样，防止过多的请求直接打到数据库上，至少能保证一部分用户使用时正常的，其他用户多刷新几次也可以访问

​                              **事后：开启redis持久化机制**，尽快恢复缓存数据，一旦重启就能从磁盘上自动加载数据，恢复内存中的数据

**缓存击穿：**

击穿与雪崩有点类似，雪崩时大规模的key失效，击穿则是某个热点key失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压剧增

   **解决方法：**

**1）互斥锁，**缓存失效后，通过互斥锁或队列来控制读数据和写缓存的数据进程，比如某个key只允许一个线程读数据和写缓存，其他线程等待。虽然防止了缓存雪崩，但是会让系统吞吐量下降

**2）热点数据永不过期，**不设置过期时间或者是当发现要过期了，通过一个后台异步线程进行再次缓存

**缓存穿透：**

指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，每请求一次该数据都要去数据库中查询一次，如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落到数据库上，造成数据库压力过大，导致数据库承受不住压力而宕机

​                  解决方法：1）将无效的key存放进redis中，当出现redis，数据库都查不到数据时，我们把这个key存入redis中，设置value=null，并设置过期时间极短，后面在出现这个key的查询直接返回null

​                                    2）使用布隆过滤器，如果布隆过滤器判断某个key不存在过滤器中，那么就一定不存在，如果判断存在，那么很大可能是存在（有一定误差），在缓存之间加一个布隆，将数据库中的所有key都存在布隆中，查询redis之前先去布隆查询，key是否存在，如果不存在直接返回，不让其访问数据库，避免对底层储存系统的查询压力

**缓存预热：**

系统上线后，提前对相关的缓存数据加载到缓存系统当中，避免用户在请求时先查询数据库，在缓存的问题，让用户直接查询实现被预热的缓存数据



### **9、Redis是单线程的，为什么读写效率还那么高？**

单个线程处理请求，避免了多个线程之间线路切换和锁资源争用的开销

6.0之后引入多线程IO，只用来处理网络数据的读写和嫌疑的解析，执行命令依旧是单线程



### **10、Redis的线程模型是什么样的？（典型的NIO，非阻塞式IO）**

NIO，非阻塞式IO



### 11、Redis过期数据的删除策略是什么？有哪些？

**最佳的删除策略：惰性删除和定期删除一起用**

惰性删除：不回去主动删除数据，而是在访问数据的时候，在检查键是否已经过期，如果过期执行删除并返回null，没过期则正常返回

定期删除：redis周期性的随机测试一批设置了过期时间的key进行处理，测试到过期的key直接删除

**常见的有三种**：

​                     1）**定时删除**，设置某个key过期的同时，创建一个定时器，让改定时器在改过期时间到来时，立即执行对其进行删除的操作

​                                       优点：对内存友好，能够保证内存的key一旦过期就能立即从内存中删除

​                                       缺点：对CPU不友好，在过期key较多时，删除过期键会占用一部分cpu时间，对服务器会造成响应时间和吞吐量的影响

​                     2）**惰性删除**，改key过期后不去管他，当需要该key的时候，在检查是否过期，如果过期就删除，反之则返回该key

​                                       优点：对CPU友好，只有在使用该key的时候才会对其进行检查，对于很多用不到的key不用浪费时间对其进行检查

​                                       缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，该键就会一直在内存中，如果有很多这种用不到的的键，这些键便永远不会删除，内存永远不会释放，从而造成内存泄漏

​                     3）**定期删除**，每隔一段时间，对进行检查，删除里面过期的key

​                                       优点：可以通过限制操作执行的时长和频率减少删除操作对CPU的影响，能够有效释放内存

​                                       缺点：难以确定定期删除时间，如果执行的频繁就会和定时删除一样，如果不平凡就会和惰性删除一样。最重要的是在获取某个键时，如果某个键的过期时间已经到了，但是还没执行删除任务，那么就会返回这个键的值，这是业务不能容忍的错误



### **12、Redis的数据淘汰策略是什么？有哪些？**

redis在内存超过最大允许的内存之后，redis会触发内存淘汰策略，删除一些不常用的，保证redis的正常运行

4.0之前的淘汰策略：（lru算法：最近使用 least recently used）

​           volatile-lru：利用LRU算法移除设置过期时间的key

​           allkeys-lru：当内存不足以写入新数据时，在键空间中移除最少使用的key（最常用的）

​           volatile-ttl：从已设置过期时间的数据集中挑选将要过期的key

​           volatile-random：从已设置过期时间的数据集中任意选择数据淘汰

​           allkeys-random：从数据集中任意选择数据淘汰

​           no-eviction：禁止淘汰数据，当内存不足时会直接报错

6.0之后新增的：

​           volatile-lfu：从已设置过期时间的数据集中挑选最不常用的数据淘汰

​           allkeys-lfu：当内存不足时，在键空间移除最不常用的key

内存淘汰策略可以通过配置文件来修改，Redis.conf对应的配置项是maxmemory-policy 修改对应的值就行，默认是noeviction。

setNx

### **13、Redis的慢查询如何排查？**

redis中有慢查询日志，直接修改配置文件或者是输入命令设置慢查询日志

**slowlog-log-slowr-then预设阈值，单位微秒**

**slowlog-max-len慢查询日志最大储存条数**

**slowlog-get 获取慢查询日志**



### **14、如何正确使用Redis的分布式事务锁？（Zookeeper也可以实现分布式锁）**

**1：加锁，使用setnx加锁**，key是锁的唯一标识，当执行setnx返回1，说明key原本不存在，该线程得到了锁。当返回0，说明key已存在，线程抢锁失败

**2：解锁，使用del解锁**，线程得到锁之后执行完任务，需要释放锁让其他线程可以进入

**3：锁超时，**setnx的key必须设置一个超时时间，以防如果得到锁的线程在执行时挂到，来不及释放，这块资源就会永久锁住，setnx不支持设置超时参数，所有需要额外指令 **expire key （时间）**

**2.6.12之后的版本set指令增加了可选参数**， seconed设置过期的秒数，milliseconed设置过期的微秒**，NX键不存在时对键进行操作，XX键存在时对键进行操作**

**问题：**

**锁误删，**当A获取到锁后，并设置过期时间为30秒，A执行的时间超过了30秒，锁过期自动释放，此时B获得了锁，随后A执行完成使用del命令释放锁，这时B还没完成任务，但是锁已经被A释放了

​           解决：在del释放锁之前加一个判断，验证当前是否为自己的锁

**超时导致并发**，当A获取到锁后并设置过期时间为30秒，A执行的时间超过了30秒，锁到期自动释放，此时线程B获取到锁了，和A并发执行

​            解决：延长过期时间，确保代码逻辑在锁释放之前执行完成。增加守护线程，为要过期但未释放的锁增加有效时间



### **15、Redis的双写一致性如何保证？**

四种方案：

1：先更新数据库，后更新缓存

2：先更新缓存，后更新数据库

**3：先删除缓存，后更新数据库**（可以用那个延时双删啊，更新数据库后面再删一次）

**4：先更新数据，后删除缓存**

第一第二种是没有人使用的，第一种方案的问题是并发更新数据库，会将脏数据刷到缓存

第二种问题是，如果先缓存更新成功，数据库更新失败则造成数据不一致

主要使用第三种或者第四种





### **16、项目搭建多级缓存的好处是什么？实现多级缓存的流程是什么？（加分项）**

充分利用请求处理的每个缓解，分别添加缓存，减轻服务器压力

- 浏览器访问静态资源时，优先读取浏览器本地缓存
- 访问非静态资源（ajax查询数据）时，访问服务端
- 请求到达Nginx后，优先读取Nginx本地缓存
- 如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）
- 如果Redis查询未命中，则查询Tomcat
- 请求进入Tomcat后，优先查询JVM进程缓存
- 如果JVM进程缓存未命中，则查询数据库

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE15617e3e139c671513653e3d8e7189b6/7620)





### **17、Redis的hash槽一共有多少个？数据是如何进行入槽的？如果实现动态扩容？**

16384个插槽

如何入槽：利用CRC16算法得出一个hash值，对16384取余，得到的结果就是slot值，如果key时num就对num取余，如果key是{CRC16}num 就对CRC16取余



# **七、Rabbitmq**

### **1、Rabbitmq消息模式有哪些？你们用的哪种？（5种）**

1：simple-queue 简单消息队列模式

2：work-queue 工作消息队列模式

3：fanount 发布订阅模式 广播

4：direct 路由模式

5：topic 主题模式

​       模式：消息生产者（routingKey）--topic交换器--与交换机绑定的队列（boudingKey）--消息消费者

​       流程：消息生产者携带routingKey发送到topic交换机，topic交换机根据更具boudingKey将消息转发到与自己绑定规则的队列中，消息消费者对队列中的消息进行消费

​       通配符说明：*匹配一个单词，#匹配多个或0个单词



### **2、Rabbitmq如何保证mq消息可靠性？（3大方面） **

1：保证消息传递不丢，开启生产者消息确认机制  

​     1）开启ConfirmCallBack回调，消息传递到交换机的回调（成功，失败，异常）

​     2）开启ReturnCallBack回调，消息从交换机未路由到队列的回调

2：保证消息达到MQ后不丢（MQ宕机了也不影响），消息持久化（默认就是持久化）

​     1）交换机的持久化    2）队列的持久化     3）消息的持久化

3：保证消费者不丢（必须至少消费一次），开启消费者消息确认机制

​     1）none 没有确认机制，如果出现异常会直接丢弃

​     2）manual：手动确认， 可以自己灵活控制消息的确认和拒收，开启这个机制之后一定要记得手动回执，否则会造成大量堆积问题

​     3）aotu 自动确认，优点：出现异常返回nack，正常执行返回ack，无需编写业务代码，无侵入（AOP）

​                                     缺点：当消费消息出现异常返回nack时会一直反复投递，

​                                              解决：开启消费者重试机制，消费消息失败时，消费者会自己发起重试，重试间隔和最大重试次数可灵活配置，当超过最大重试次数时，消费者对于消息有以下几种策略

​                                               1：直接丢弃，该消息从MQ删除

​                                               2：放回消息队列，然后投递给消费者，消费者进行重试，如此循环

​                                               3：投递至指定的交换机，绑定队列后进行精准消费



### **3、Rabbitmq如何实现延时消息？（2种）**

1：利死信交换机实施延迟传递

​      原理：设置消息超时未被消费会被投递至死信交换机

​      设置超时：1：针对消息设置延迟时间   2：针对队列设置延迟时间

2：利用延迟交换机插件实现延迟传递

​      原理：交换机延时路由，达到指定的时间会被路由至队列



### **4、什么是死信队列？什么样的消息会进入死信队列？**

处理垃圾信息的队列，有以下三种消息会进入死信队列

1：被拒绝或nack的消息

2：队列放不下的消息

3：超时过期的消息



### **5、Rabbitmq如何解决消息堆积问题？（3种思路）**

1：针对同一队列增加多个消费者进行消费

2：针对同一消费者开启多个线程进行消费

3：加大队列的储存容量，惰性队列

​       原理：直接将消息写入到磁盘

​       优点：储存容量大，减少从内存刷消息数据到磁盘的次数，性能稳定

​       缺点：性能取决于IO



### **6、如何保证消息的幂等性？（从业务层面进行判断）**

**幂等性的实质：**对于一个资源，不管时一次请求还是多次请求，对资源本身造成的影响应该是相同的，不能因为重复的请求而对该资源造成影响

**首先要知道什么情况下MQ会非幂等**

1：consumer接收到消息处理完成后，给broker返回ack途中断网，broker未收到确认消息，根据MQ的重试机制，则会再次发送该消息给consumer，造成消息的重复消费

2：在开启生产者confirm模式下，生产者已经把消息发送给broker，但在broker传回ack确认时断网，生产者也会重新发送消息，造成broker收到了重复的消息，最后这两条重复的消息都会发送给消费端，造成了消息的重复消费

**通过这两种场景，我们可以得知MQ的幂等性保障应该是在消费端，要保证MQ的幂等性，就要保证消费者不会重复消费消息**

如果解决这个问题：

**设置全局唯一ID+redis**

生产者在发送消息时，**为每一条消息生成一个全局唯一messageid，消费者拿到消息后，使用setnx命令，将messageid作为key放入redis中**，setnx（messageid，1）若返回1说明之前没有被消费过，正常消费。若返回0表示这条消息已经被消费过，抛弃

### 7.如何保证mq的顺序性

1、拆分多个 queue，每个 queue 一个 consumer(消费者)。

2、一个 queue，但是对应一个 consumer，然后这个 consumer 内部用内存队列（其实就是List而已）做排队，然后分发给底层不同的thread来处理（此方案可以支持高并发）

### 8,Rabbit的集群有哪几种

普通集群

镜像集群

仲裁队列

# **八、微服务**

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE7a382620e71c1ba91b53e7b02fdf11f7/8204)



### **1、概念问题**

​		**1）、什么是微服务？解决微服务各种问题都用了哪些组件？**

分布式架构：对单体架构进行拆分，解耦，有利于服务器拓展

微服务本质上是经过各大公司校验的一个优秀的分布式架构

组件：dubbo，SpringCloud，SpringCloudAlibaba



​		**2）、什么是单体架构、什么是分布式架构、什么是微服务架构？**

单体架构：所有的业务，模块耦合在一个项目中，容易产生系统瘫痪

分布式架构：对单体架构进行拆分，解耦，有利于服务器拓展

微服务架构：本质上是经过各大公司校验的一个优秀的分布式架构



​		**3）、微服务有哪些特点？**

1：单一职责，对业务进行颗粒化细分，避免重复代码的编写

2：面向服务，暴露提供的restful风格接口

3：自治

4：服务隔离，服务之间互不影响，熔断，降级，防止级联雪崩

用getway是用来进行统一请求的路由分发



### **2、远程调用**

​		**1）、什么是Feign，用来做什么的？Feign底层调用是怎么实现的？底层协议是什么？优势是什么？**

什么是feign：Feign是一个声明式的Http客户端

用来做什么的：帮我们优雅的实现Http请求的发送

底层调用：打上@FeignClient注解，基于面向接口的动态代理方式生成实现类，将请求委托到动态代理实现类

底层协议：Contrect协议



​		**2）、服务间调用，其中一个服务宕机了，这个时候怎么做呢？**

​			对故障的服务进行限流，重启

​		**3）、Ribbon是什么？负载均衡策略有哪些？底层原理是什么？默认是哪种？**

Ribbon是什么：Ribbon是一个简化客户端远程调用的负载均衡器

负载均衡策略：

RoundRobinRule：简单的轮询服务来选择服务器，默认的规则

BastAvailableRule：忽略短路的服务器，选择并发低的服务器

RandomRule：随机选择一个服务器

RetryRule：重试机制的选择逻辑



​		**4）、Ribbon是如何实现轮询的？如果让你自己实现轮询，如何实现？**	

Ribbon会拦截我们的TestTemplate请求

RibbonLoadBalancerClient会从请求Url中获取服务器名称

DynamicServerListLoadBalancer根据服务器名称到注册中心拉取服务列表

注册中心返回列表，IRule根据内置负载均衡规则，从列表中选择一个，例如localhost：8080

RibbonLoadBalancerClient修改请求地址，用localhost：8080代替服务器名发起真实请求



​		**5）、Feign和Ribbon的关系是什么？**

Ribbon是一个基于Http和TCP客户端的负载均衡工具，

Feign是在Ribbon的基础上做了改进，是一个使用起来更加方便的Http客户端，采用接口方式，将需要调用的服务定长成抽象接口，不需要自己构建Http请求



​		**6）、你们项目中如何使用Feign的（Feign的最佳实践）**

最佳实现由两种，继承和抽取

继承：不推荐，定义一个API接口，利用定义方法，并基于Spring'MVC注解做声明，Feign客户端和Controller都集成该接口，不过缺点太明显，服务提供方和消费方紧密耦合，而且参数列表中的注解映射并不会继承

抽取：推荐，将Feign的Client抽取为独立模块，并且把接口有关的的POJO，默认的Feign配置都放在这个模块中，给所有消费者使用



​		**7）、Feign远程调用时的日志级别有哪些？**

NONE：不记录任何日志信息，这是默认值。

BASIC：仅记录请求的方法，URL以及响应状态码和执行时间

HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息

FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。



​		**8）、如何优化Feign的调用性能？**

1：日志级别尽量用Basic

2：使用HttpClient或OKHttp代替URLConnection（这个URLConnction是默认实现，不支持连接池）



​		**7）、Feign的默认超时时间是多久？重试次数是几次？**

超时时间是一秒，重试是一次



​		**8）、Dubbo服务注册与发现的原理？（官方原理图）**

内部结构角色：服务提供者，注册中心，服务消费者，监控中心，运行容器

Consumer：调用远程服务的服务消费者

Registry：服务注册与发现的注册中心

Provider：暴露服务的提供方

Monitor：统计服务和调用次数和调用时间的监控中心

流程：

服务容器负责启动，加载，运行provider

provider在启动时，向registry注册自己提供的服务

Consumer在启动时，向registry订阅自己所需要的服务

registry返回provider地址给Consumer，Consumer会保存地址列表，如果有更变registry将基于长连接推送变更数据给Consumer

Consumer从privider提供的地址列表中，基于自己的负载均衡算法，选一台进行调用，如果调用失败，再选另一台

Consumer和provider，在内存中调用的次数和时间，定时每分钟发送一次统计数据给monitor

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE24547c31e901e29265d0d7863a8451cb/8473)



​		**9）、Dubbo负载均衡策略有哪些？默认是哪种？**

 random ：按权重随机，默认值。按权重设置随机概率。（默认）

 roundrobin ：按权重进行轮询调用。

 leastActive：最少活跃调用数，Dubbo认为活跃度最小的性能会更高，而相同活跃数进行随机调用。

 consistentHash：一致性 Hash，相同参数的请求总是发到同一提供者。



​		**10）、Dubbo支持哪些通信协议？默认是哪种？一般用哪种协议？有什么好处？**

dobbo协议，rmi协议，webserver协议，http协议，hession协议，thrift协议，memache，redis，rest协议

默认是dobbo协议

好处：适合大并发小数据量的服务调用，以及服务消费者远大于服务提供者的情况，缺点是不适合传送大数据包服务



​		**11）、注册中心挂了影响服务调用吗？为什么？**

会继续通信，注册中心全部宕机，会依靠本地缓存通讯



​		**12）、Dubbo启动检查如何设置？多版本支持如何设置？**

启动检测设置：在yml里面配置，consumer：check=false 是关闭

多版本设置：在服务实现类的@DubboService注解上指定版本 version=”版本号“

​                     在消费者调用时@DubboReference后指定版本version=”版本号“



​		**13）、Dubbo的默认超时时间是多久？重试次数是几次？**

超时时间一秒，重试次数两次



​		**14）、Dubbo进行服务注册和发现的核心注解是哪个？**

服务注册@DubboService   服务发现@DubboReference



​		**15）、Dubbo服务如何进行监控和管理？**

在gitHub上下载Dubbo-admin





### 	**3、注册中心**

#### 		**1）、Eureka**

​			**1、eureka是属于什么体系的技术（Spring Cloud）**

springcloud



​			**2、eureka技术体系有哪些角色？（服务端用作注册中心，客户端用作微服务）**

服务器用作注册中心，客户端用作微服务

**Eureka server  ，Eureka Client**



​			**3、eureka的自我保护机制是什么？什么时候开启？为什么开启？开启了会发生什么？**

**自我保护机制**：为了防止当微服务状态正常，网络分区故障，导致实例被误杀而提供的一种保护机制

**什么时候开启**：Eureka server 在运行期间会去统计心跳失败比例在15分钟内是否低于85%，如果低于85%，Eureka server则会进入自我保护机制

**开启了会发生什么：**1）Eureka不再从注册列表中移除因为长时间没收到心跳而应该剔除的服务

​                                 2）Eureka仍然会接收新服务的注册和查询，但是不会同步到其他节点上，保证当前节点依然可用

​                                 3）当网络稳定时，当前实例新的注册消息会被同步到其他节点中



​			**4、eureka作为注册中心的原理是什么？心跳检测某个服务是否健康的原理详细说下？**

**原理**：Eureka server主要对外提供三个功能

**服务注册：**服务提供者启动时，会通过Eureka Client向Eureka Server注册消息，Eruka Server会储存该服务的信息，内部有两层缓存机制来维护整个注册表

**提供注册表：**服务消费者在调用服务时，如果Eureka Client没有缓存注册表的话，会从Eureka Server获取最新的注册表

**同步状态**：Eureka Client通过注册，心跳机制，和Eureka Server同步当前客户端的状态



​			**5、eureka集群是属于AP还是CP？(AP)**

​			了解ap;





#### 		**2）、Nacos**  

​			**1、nacos是属于什么体系的技术（Spring Cloud Alibaba）**

Spring CloudAlibaba



​			**2、nacos作为注册中心的原理是什么？**

**服务实例启动时到服务注册表，服务消费者可以查询服务注册表来获得可用实例，**



​			**3、nacos如何确定唯一的一个服务?（通过namespace、group、service、集群唯一确定一个服务）**

Nacos提供了**namespace来实现环境隔离**，Nacos中可以有多个namespace，**namespace下可以有group，service等，不同namespace之间相互隔离**



​			**4、nacos中namespace、group分别的作用是什么？**

namespace可以相当于一个空间，空间里面有group，service

gorup是分组，一般都是默认分组



​			**5、nacos和eureka的异同有哪些？**

共同点：**都支持服务注册，服务拉取，服务提供者心跳方式做健康检测**

不同点：**Nacos支持服务端主动提供检测提供者状态**，**临时实例采用心跳检测模式，非临时实例采用主动检测模式**

​              **Nacos临时实例心跳不正常会被剔除，而非临时实例不会**

​              Nacos支持服务列表变更的消息推送模式，服务列表更新更及时

​              **Nacos集群默认采用AP模式**，**当集群中存在非临时实例时，采用CP模式**。**Eureka采用AP模式**



​			**6、nacos的临时节点和非临时节点有什么区别？**

临时实例：如果实例出现宕机超过一定时间，**会从服务列表剔除，默认类型**

非临时实例：如果实例宕机，**不会从服务列表剔除**



​			**7、nacos集群是属于AP还是CP？(AP或CP)**

没有非临时实例时时AP，如果存在非临时实例就是CP



​			

#### 		**3）、Zookeeper**

​			**1、Zookeeper的内部结构是什么？**

zookeeper的数据模型很像树，树由节点组成，里面储存数据，节点叫做Znode，znode的引用方式是路径引用，类似文件路径，这样的层级结构让每一个znode节点拥有唯一的路径

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE16b580b345ab00fc0e174b756d021147/8188)



​			**2、使用Zookeeper作为分布式事务锁的原理是什么？**

原理：Zookeeper有一个特性，就是多个线程去Zookeeper里面去**创建同一个节点**的时候，**只会有一个线程去执行**



​			**3、Zookeeper集群属于AP还是CP？(CP)**

cp



​			

​	

### 	**4、配置中心**

​		**1）、实现配置中心都可以使用哪些技术？**

Spring-Cloud-Config，Nacos



​		**2）、使用nacos作为配置中心，如何实现热更新？**

方式一：在@value注入的变量所在类添加**@RefreshScope**

方式二：使用**@ConfigurationProperties**注解代替@Value



​		**3）、nacos作为配置中心，为什么需要用到bootstrap文件？**

 微服务拉取Nacos管理的配置，并且与本地的Application.yml配置合并，才能完成项目的启动

如果尚未读到Application.yml，又如何得知Nacos地址呢，所以spring引入了一个新的配置文件，**bootstrap，这个文件会在Application之前读取**



​		**4）、远程配置文件和本地配置文件属性加载优先级是什么样的？**

远程带环境的配置>远程共享配置>本地配置

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE011fbca3748af0f8c3b38db21d221b63/8251)



​		**5）、使用配置中心的好处是什么？能解决什么问题？**

如果没有配置中心，将会出现很严重的问题

- **安全性**：配置跟随源代码保存在代码块中，容易造成配置泄漏
- **时效性**：修改配置，需要重启服务器才能生效
- **局限性：**无法动态调整，如日志开关，功能开关

有了配置中心之后这些问题都能解决



​	

### 	**5、服务保护**

#### 		**1）、Hystrix**  

​			**1、hystrix是属于什么体系的技术？（SpringCloud）**

Spring-Cloud



​			**2、hystrix可以用来干嘛？（服务熔断降级）**

服务熔断降级



​			**3、hystrix默认的触发熔断策略是什么？（5分钟之内服务调用异常比例达到一半或者失败次数超过20次）**

**五分钟**之内服务调用**异常比例达到一半或是失败次数超过20次**



​			**4、hystrix的隔离是基于什么？（线程池隔离【低扇出】）**

**线程池隔离**，底扇出



#### 		**2）、Sentinel**       

​			**1、sentinel可以用来干嘛？（限流、隔离、熔断、降级）**

限流，熔断，降级，隔离



​			**2、什么是微服务雪崩现象？如何解决微服务雪崩问题？**

雪崩状态：微服务之间**相互调用**，因为调用链中的**一个服务故障**，引起**整个链路都无法访问**的情况

解决：**预防层面使用限流，问题解决层面可以用超时处理，舱壁模式也就是隔离，熔断和降级**

我们是在控制台进行配置的

​			**3、sentinel的限流模式有哪些？分别的运用场景是什么？**

**限流模式有直联，关联，链路，限流效果有快速失败，warm up，排队等待**

- **直联**：统计当前的资源请求，触发阈值时对该资源进行限流
- **关联**：统计当前资源相关的另一个资源，触发阈值时，对当前资源限流
- ​          **场景**：比如用户支付时需要修改订单状态，同时用户要查询订单，查询和修改操作会去抢数据库锁，产生竞争。业务需求是优先支付和更新订单业务，因此当修改订单业务触发阈值时，对查询订单业务限流
- **链路**：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流
- ​          **场景**：查询商品和创建订单业务，两者都需要查询商品，这个时候业务需求是优先满足创建订单，这时就可以对查询商品做限流





​			**4、sentinel的限流效果有哪些？分别的运用场景是什么？**

- **快速失败：**达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。是默认的处理方式。
- **warm up：**预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。
- ​                  **场景**：预热启动 ，当一个服务刚刚启动时，一切资源未能初始化，如果直接将QPS跑到最大值，会导致宕机，这个时候就需要warm up      
- **排队等待：**让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长
- ​                  **场景**：快事失败和 warm up在超出QPS阈值时都会直接抛出异常，而排队等待则会让所有请求进入一个队列中，按照阈值运行的时间间隔依次执行，后面的请求必须等待前面的执行完成



​			**5、sentinel支持对热点参数进行限流吗？**

支持



​			**6、实现微服务调用隔离有两种方式（信号量隔离和线程池隔离），区别是什么？sentinel是使用的哪种？**

**隔离方式：**信号量隔离和线程池隔离，sentinel默认采用的是信号量隔离

区别：

**信号量隔离**：**优点**：轻量级，无额外开销  **缺点**：不支持主动超时，不支持异步调用 

**线程池隔离**：**优点**：支持主动超时，异步调用  **缺点**：线程的额外开销大

当然sentinel也可以实现线程隔离，就是开启舱壁模式



​			**7、什么是熔断？熔断的原理是什么？什么时候会触发sentinel的熔断？断路器的三种状态是哪些？是怎样进行切换的？**

**什么是熔断**：拦截访问该服务的一切请求，当服务恢复时，断路器会放行访问该服务的请求

**原理：**由断路器统计服务的异常比例，异常数，慢请求比例，如果超出阈值就会熔断该服务

断路器三种状态：

**closed：关闭状态**，断路器会放行所有请求，并开始统计异常比例，异常数，慢请求比例，**超过阈值则会切换到open状态**

**open：打开状态，**服务调用将会熔断，访问熔断服务的请求会被拒绝，快速失败，直接走降级逻辑，**open状态5秒后会进入half-open状态**

**half-open：半开状态**，**放行一次请求如果请求成功切换到closed状态，请求失败切换到open状态**







​			**8、什么是降级？如何实现降级？**

降级：可以理解为，我访问这个服务失败了，但是又不能直接给用户显示出来，这个时候给一个别的画面给用户看，可以是404，也可以是请稍后

**实现降级：客户端定义降级方法，方式由两种**

​                  **1：FallBackClass**

​                  **2：FallBackFactoryClass（一般用这个好点，可以直接获取服务端抛出的异常）**



​			**9、sentinel授权规则是用来干什么的？**

**对请求方**来源做**判断和控制**，有**黑白名单两种方式**，可以让**网关来访问该资源，禁止服务器直接访问**



​			**10、sentinel的规则持久化方式有哪些？一般使用哪种？**

**原始模式**：**Sentinel默认方式**，将规则保存到内存中，重启服务会丢失

pull模式：控制台将配置推送到远程控制中心，如Nocas

push模式



​			

​	

### 	**6、网关**

​		**1）、网关有什么作用？在你们项目中用网关来干嘛了？**

把网关当作防火墙，一切访问服务的连接都要经过网关，是所有微服务的入口

网关的作用：权限控制，路由和负载均衡，限流



​		**2）、网关的核心技术点有哪些？**

路由，过滤工厂，断言工厂

  

​		**3）、网关的路由是用来干嘛的？分为哪几种？**

路由就是把这个拦截到访问的网址后，校验这个网址后去访问我们微服务的真实配制的路径

种类分两种：静态路由，动态路由



​		**4）、网关的过滤器是用来干嘛的？分为哪几种？**

过滤器可以对进入网关的请求微服务返回的响应做处理

分为三种：默认过滤器，局部过滤器，全局过滤器



​		**5）、网关局部过滤器和全局过滤器的区别有哪些？**

局部过滤器由内置的三十一种局部过滤器工厂，可以针对某个路由配置，或针对全部路由的默认过滤器

全局过滤器需要自己通过代码实现，实现Filter方法，执行顺序要用过order接口或是注解，一般用来定义各个web服务的公共逻辑，如用户鉴权，日记记录等



​		**6）、网关中局部过滤器、默认过滤器、全局过滤器的执行顺序是什么？**

先看order属性，order属性越小越先执行，如果一样执行顺序为默认，局部，全局



​		**7）、加入网关后，访问一个链接，你们项目的执行流程是什么？**

geteway Client向geteway Server发送请求

请求会被HttpWebHandlerAdapter进行提取组装成网关上下文

将网关上下文传递到DispatcherHandler，它负责将请求发送给RoutePredicateHandlerMapping

RoutePredicateHandlerMapping负责路由查找，并根据路由断言判断路由路由是否可用

如果断言成功，由FilteringWebHandler创建过滤器链并调用

请求一次会经过preFilter—微服务—postFilter，最终返回响应



​		**8）、定义全局过滤器需要实现哪几个接口？**

实现filter接口和order接口



​		

​	

### 	**7、分布式事务**

​		**1）、什么是本地事务？什么是分布式事务？**

本地事务：无需跨越多个服务或者数据源的单体事务，一般都是由spring控制

分布式事务：指一个业务跨越多个服务或数据源，每个事务叫分支事务，要保证所有分支事务，要么全成功，要么全失败



​		**2）、什么是CAP定理？为什么必须保证P？为什么在保证P的前提下只能保证C或者A其中一个？**

CAP：P必须满足，C或A满足其中一个

C：数据一致性，任何时候，访问任何节点返回的数据都是一致的

A：服务可用性，任何时候，访问任何节点都要能够得到响应

P：分区容错性，因为网络故障或其他原因导致分布式系统中部分节点与其他节点失去连接，要形成独立分区，出现分区后整个系统也要持续对外提供服务



​		**3）、什么是BASE理论？**

Basically Avalible（基本可用）：分布式系统出现故障时，允许损失部分可用性，保证核心可用

Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态

Evantually Consistent（最终一致性）：虽然无法保证强一致，但在软状态结束后，最终达成数据一致



​		**4）、seata解决分布式事务的三个角色以及分别的作用什么？**

TC 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚

TM 事务管理者：定义全局事务范围，开始全局事务，提交或回滚

RM 资源管理者：管理分支事务处理的资源，与TC交谈注册分支事务和报告分支事务，并驱动分支事务提交或回滚



​		**5）、seata解决分布式事务的四种模式**

TA：强一致性分阶段事务模式，牺牲了一定的可用性，无业务入侵

AT：最终一致的分阶段事务模式，无业务入侵，也是Seate默认模式

TCC：最终一致的分阶段事务模式，有业务入侵

SAGA：长业务模式，有业务入侵

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE1e4f9e2a20f65fcd53d35d80b0d76b29/9270)



​		**6）、XA模式特点、原理以及应用场景？优缺点有哪些？**

XA：强一致性分阶段事务模式，牺牲了一定的可用性，无业务入侵

原理：

- ​        第一阶段：
- ​                         TM开启全局事务，调用分支事务
- ​                         TC接收开启全局事务请求
- ​                         RM将分支事务注册到TC，执行本地SQL但不提交，将本地事务状态报告给TC
- ​        第二阶段：
- ​                         TM等一阶段所有分支事务执行完，发起提交/回滚全局事务
- ​                         TC接收全局事务提交/回滚请求，查询所有的分支事务状态，对RM发起提交/回滚命令
- ​                         RM依赖数据库，提交/回滚当前的分支事务

优点：强一致性，无代码入侵，简单

缺点：强依赖于关系型数据库实现回滚，性能较差



​		**7）、AT模式特点、原理以及应用场景？优缺点有哪些？有可能会出现什么问题？如何解决？**

AT：最终一致的分阶段事务模式，无业务入侵，也是Seate默认模式

原理：

- ​        第一阶段：
- ​                         TM开启全局事务，调用分支事务
- ​                         TC接收开启全局事务请求
- ​                         RM将分支事务注册到TC，执行本地SQL提交，执行前拍一个快照Undo-log，将本地事务状态报告给TC
- ​        第二阶段：
- ​                         TM等一阶段所有分支事务执行完，发起提交/回滚全局事务
- ​                         TC接收全局事务提交/回滚请求，查询所有的分支事务状态，对RM发起提交/回滚命令
- ​                         RM依赖于Undo-log快照数据，提交/回滚当前的分支事务

优点：一阶段可用直接提交事务，释放资源，性能较好。利用全局锁实现读写隔离，没有代码入侵

缺点：二阶段属于软状态，属于最终一致。框架的快早功能也会影响性能，但是比XA也好很多

可能出现的问题：脏写，当全局事务1提交修改的数据后，此时全局事务2又过来修改了这条数据 后续阶段二全局事务1需要利用快照进行回滚，将全局事务2的所有修改进行了覆盖

如何解决：seata内部提供了全局锁的概念（需要在seata server新增一张全局锁的表但是全局锁有可能导致死锁（内部通过限制获取全局锁的次数来解决：30次/10ms）



​		**8）、重点：TCC模式特点、原理以及应用场景？优缺点有哪些？有可能会出现什么问题？什么是空回滚和业务悬挂，如何解决？**

TCC：最终一致的分阶段事务模式，有业务入侵

原理：和AT一样，不过TCC时依靠人工编码来实现数据恢复，属于最终一致(AP)

优点：一阶段直接提交事务，释放资源性能好。相比AT无需生成快照和全局锁，性能最好。不依赖数据库事务，而是依赖补偿操作，可以用于非事务性数据库

缺点：代码入侵，便要人为编写Try，Confirm，Cancel接口。软状态，最终一致性。需要考虑Confirm和Cancel失败的情况，需要做幂等性处理

问题：空回滚和业务悬挂

空回滚解决：

- 问题描述：当某分支事务的try阶段阻塞时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，则就是空回滚。
- 问题解决：执行cancel操作时，应当判断try是否已经执行，如果尚未执行，则应该空回滚。

业务悬挂解决：

- 问题描述：对于已经空回滚的业务，之前被阻塞的try操作恢复，继续执行try，就永远不可能 confirm或cancel ，事务一直处于中间状态，这就是业务悬挂。
- 问题解决：执行try操作时，应当判断cancel是否已经执行过了，如果已经执行，应当阻止空回滚后的try操作，避免悬挂



​		**9）、SAGA模式特点、原理以及应用场景？优缺点有哪些？**

SAGA：长业务模式，有业务入侵

原理：分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。

优点：一阶段直接提交事务，无锁，性能好。不用编写TCC的三个阶段，实现相对简单。事务参与者可以基于事件驱动实现异步调用，吞吐高

缺点：没有锁和事务隔离，会有脏写。软状态持续时间不确定，时效性差





## **九、ElasticSearch**

### 	**1、什么是ES？由什么语言编写？和Lunce的关系？什么是ELK？**

什么是ES：高性能，高扩展，分布式，支持海量数据分析，搜索，计算的搜索引擎

java语言编写，前身是lucene

ELK：是一个围绕ElasticSearch的技术栈，包含ElasticSearch，logstash，Kibana



### 	**2、ES的核心概念有哪些？什么是索引？什么是文档？文档格式是什么？什么是映射？什么是DSL？**

索引：index，同一个类型文档的集合，相当于msql的表

文档：document，josn格式的数据，相当于msql的行（row）

字段：field，一个个的字段，相当于msql的列（Column）

映射：mapping，对索引结构的约束，相当于msql的表结构（schema）

DSL：json风格符合restful风格的语句



### 	**3、什么是倒排索引？倒排索引建立过程？**

什么是：在文档增删改的时候对文档进行合理化分词

过程：形成一个不重复的词条列表，每一个词条对应一个文档ID，将来根据文档找ID，在根据ID找到对应的文档，涉及了两次btree查询



### 	**4、ES有哪些数据类型？keyword和text有什么区别？**

字符串：test（可分词的文本），keyword（精确值，例如：品牌，国家，ip）

数值：long，integer，short，byte，double，float

布尔：boolean

日期：date

对象：Object



### 	**5、重要：说说用户输入框输入查询条件 进行ES搜索的底层原理过程**

1. 客户端发送请求到coordinate node
2. 协调节点将搜索请求转发到所有shard对应的primary shard或replica shard
3. 每个shard将自己的查询结果（就是一些doc id），返回给协调节点，由协调检点进行数据合并，排序，分页，产出最终结果
4. 由协调节点，根据doc id去各个节点上拉取document数据，最终返回给客户端



### 	**6、ES分词器适合在什么字段上使用？分词器在ES中的使用场景有哪些？（建立倒排索引时对文档分词和用户搜索时对搜索条件分词）**

分词器一般在全文检索上使用

场景：百度输入框

### 	**7、你们分词器用的哪种？为什么要自定义拼音分词器？为什么搜索时不能用拼音分词器？**

自定义分词器

由于客户端面对国人，需要有拼音分词器，但由于默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。

###         **8、ES有哪些查询类型，分别用在什么场景？如何实现复合查询？要给指定的数据进行加分如何实现？**

查询类型：全文检索，精确查询，地理坐标查询，复合查询

如何实现复合查询：符合查询里面有算分函数查询，布尔查询，在query模块后加一个functions，加上函数条件即可实现



### 	**9、ES能对搜索结果进行哪些处理？如何实现高亮？**

排序，分页，高亮

实现高亮：高亮是对关键字高亮，搜索条件必须带有关键字，默认情况下高亮的字段必须与搜索指定的字段一样，否则无法高亮，如果一定要对非搜索字段高亮，需要添加一个属性“required_field_match=false”

高亮则是在和qeury同一级上添加highlight属性，在fields属性里面添加高亮字段



### 	**10、ES有哪些聚合查询？**

常见的聚合操作：

bucket（桶）：用来对文档做聚合操作

metric（度量）：用来计算一些值，例如最大最小值，平均值

pipeline（管道）：其他聚合的结果为基础做聚合



### 	**11、ES如何实现自动补全查询**

由于是对于国人的搜索引擎上的补齐，需要的是pinyin分词器



### 	**12、如何自定义分词器？**

首先要知道分词器分为三部分，character filter在tokenizer之前对文本进行处理例如删除字符和替换字符，tokenizer将文本按照一个规则切割成词条，tokenizer filter将tokenizer输出的词条做进一步处理，例如大小写转换，同义词处理，由于默认的拼音分词器会将每个汉字单独分为拼音，而我们希望是每个词条形成一组拼音，需要对拼音分词器做个性化定制，tokenizer部分选择ik_max_word分词器，filter：“py”，然后在自定义一个tokenizer filter 过滤器名称py，“type”：pinyin分词器，后面在根据自己需要的业务调整pingyin分词器的属性	

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE8db8b4a154d1733c396881493ea82dd6/9571)



### 	**13、如何实现es与mysql的数据同步？**

举例三种方案：

1. 同步调用
2. MQ异步调用
3. 监听binlog



### 	**14、es集群节点有哪些类型？分别的职责是什么？**

​    ![0](https://note.youdao.com/yws/public/resource/05a9ab7d3dbc8584b065d13f768a2b6c/xmlnote/WEBRESOURCE34b2cc00bbe00326f9745df71ad619e4/9629)

master node：对CPU要求高，但是对内存要求低

date node：对CPU和内存要求都要高

coordinating node：对网络宽带，CPU要求高



### 	**15、什么是es脑裂问题？**

假设有三个node，主节点与其他节点失联，这时另外两个节点会认为主节点宕机了，会推举新的主节点出来，当新的主节点诞生后，此时之前的主节点又恢复过来。这样就会让失联之前的主节点和推举的主节点自成两个集群，出现数据差异

解决：要求选票超过（节点数量+1）/2，因此最好节点的数量是奇数，在ES7.0以后就默认该配置了，一般不会出现



## **十、Docker**

​	1、什么是Docker？优点是什么？有哪些核心概念？

​	2、镜像操作命令有哪些？

​		拉取、推送、查看、查看所有、删除、删除所有、制作镜像、导出镜像、加载镜像

​	3、容器操作命令有哪些？

​		查看所有、查看正在运行的容器、删除、强制删除、创建容器、创建并运行、

​		启动容器、停止容器、重启容器、暂停容器、恢复容器、进入容器

​	4、数据卷操作命令有哪些？

​		创建数据卷、查看单个数据卷详情、查看数据卷列表、删除数据卷、删除未使用的数据卷、创建容器时挂载数据卷

​	5、docker如何自定义镜像？docker file的语法是什么样的？

## **十一  MongDB **

mongBD 分片集群  分为哪几个角色

分片服务

配置服务

路由服务

![image-20220510202622997](C:\Users\LEGION\AppData\Roaming\Typora\typora-user-images\image-20220510202622997.png)

分片服务 是用来存储数据的 每个分片服务存储的数据是不一样的 多个分片服务构成了完整的mongDB集合

配置服务 在启动的时候会读取所有的分片服务器的信息存储到配置服务器里面

路由服务 在启动时会读取配置服务中存储的所有的分片服务的信息 同时用户客户端发送请求到路由服务 然后路由服务根据其中的规则去选择分片服务

